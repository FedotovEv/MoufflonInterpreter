
Взаимодействие Муфлон-скрипта с внешним миром - специализированный поток вывода.
--------------------------------------------------------------------------------

Здесь находится пример применения ещё одного механизма, позволяющего Муфлон-программе
обмениваться данными с внешним миром - механизма специального выходного потока,
позволяющего передавать весь выход команды print вовне для любой требуемой обработки. 
Этот механизм позвоялет организовать только односторонний обмен данными - из
скрипта-передатчика к внешнему получателю.

Предлагаемый здесь способ достижения этой цели - создание какого-либо нестандартного
выходного потока, приводимого к ostream. Внутренняя его логика будет определяться
только конкретной задачей, которая и будет определять, что именно следует делать с
поступающей из Муфлон-программы информацией. Экземпляр такого потока затем следует
установить в исполнительский контекст программы в качестве текущего выходного канала,
который и будет использоваться командой print при своей работе.

Создание потока, совместимого с ostream, само по себе может оказаться сложной задачей.
Но так как полнофункциональный поток нам не нужен, можно ограничиться его элементарной
версией, достаточной, тем не менее, для функционирования print. Самый простейший способ
решения такой задачи и приведён в предлагаемом примере.

Любой С++-поток ввода/вывода содержит в себе ряд внутренних объектов и сущностей. Для
существенного видоизменения работы потока достаточно заменить лишь одну из них - потоковый
буфер. И интерфейс потоков C++ построен так, что позволяет решить эту задачу очень простыми
средствами - достаточно создать собственный класс потокового буфера, унаследовав его от
стандартного streambuf, а затем передать указатель на полученный этим способом объект
конструктору класса ostream. Организованный таким образом поток уже вполне готов к передаче
его конструктору runtime::SimpleContext и последующему его использованию в качестве целевого
объекта для команды print языка Муфлон.

Потоковый буфер - тоже весьма многосложный объект, обеспечивающий различные режимы доступа
к данным подлежащего источника, как буферизованные, так и небуферизованные. Поддержка всего
функционала производится переопределением множества его виртуальных функций. Но для обеспечения
минимальной работоспособности системы достаточно реализовать лишь одну из них - overflow,
оставив все прочие в их исходном состоянии. Эта функция в таком случае будет последовательно,
байт за байтом, получать все символы, выходящие из потока, а дальнейшая их судьба уже будет
определяться исключительно её собственным алгоритмом.

Именно так и устроен предлагаемый демонстрационный пример. Возможно, он и не отличается
высоким быстродействием, но, тем не менее, работает. На данный момент этого вполне достаточно.
