
Интерпретатор языка программирования МУФЛОН.
============================================

  Перед   вами     интерпретатор     одного     очень    специфического    языка
программирования   -   Mython.   Транскрипция  этого  слова  в  русский  алфавит
должна   выглядеть  приблизительно  как  "Митон",  но  для  того,  чтобы  слегка
поднять  настроение  всякому, читающему  эти  строки,  по-русски  далее мы будем
называть этот язык программирования так - "Муфлон".

  Сама  реализация  этого   интерпретатора   велась  одновременно  с  чтением  и
проработкой   известной   "книги   дракона"   -   Ахо,   Ульман,  пр.  "Принципы
разработки компиляторов". Так что первоначально проект носил полностью учебно-
образовательный характер. Но в дальнейшем за свою короткую восьмимесячную историю
он уже вполне развился, вырос и окреп, так что теперь его вполне можно применять
и в практическом программировании. Во всяком случае, для него уже можно указать
несколько практических ниш, в которых его применение будет вполне допустимым и
даже уместным. В конце этого документа такой вопрос будет рассмотрен особо и там
будет предложено несколько таких областей, в которых можно задействовать как
данный язык, так и его интерпретатор, созданный в рамках этого проекта.

  Что  же такое  Муфлон?  Как следует  даже  из  названия,  это некоторый, очень
сильно    урезанный    вариант    широко   распространённого   интерпретируемого
скриптового   языка   Питон. Руководящий принцип проектирования - минимализм. Из
прототипа исключена  масса  конструкций,  которые можно рассматривать как
"синтаксический сахар", а также те, которые могли бы затруднить проектирование
"теоретически ясного", архитектурно-чистого транслятора на основе стандартного
абстрактного синтаксического дерева.

  Описанию  самого  этого языка, его лексики и синтаксиса, будет посвящена отдельная
идущая ниже глава.

Описание языка программирования Муфлон.
---------------------------------------

  Муфлон     -     объектно-ориентированный      язык     программирования     с
поддержкой классов и наследования. Все методы классов — виртуальные.

* Числа.  
  В языке Муфлон используются целые и дробные числа. С ними  можно выполнять
обычные арифметические операции: сложение, вычитание, умножение, деление (если
оба его операнда - целые числа, то результат тоже будет целочисленным), а также
деление по модулю (взятие остатка от деления). Последнее, вопреки обыкновению,
определено также и для дробных чисел.  
Кроме того, в языке существуют и некоторые другие действия, определённые над
множеством чисел, как целых, так и дробных. Это разнообразные побитовые операции - 
унарное двоичное дополнение (НЕ, комплемент, обозначается символом ~), ряд битовых
бинарных (двухаргументных) операций - двоичное И (&), ИЛИ (|), исключающее ИЛИ
(^), а также побитовые сдвиги влево (<<) и вправо (>>).  
Все они должны быть привычны программистам на C/C++, хотя и имеют несколько
отличающуюся семантику и приоритеты.

* Строки.  
  Строковая  константа  в   Муфлоне   —   это   последовательность  произвольных
символов (узких, однобайтовых),  размещающаяся  на  одной  строке  и  ограниченная
двойными кавычками " или одинарными '. Поддерживается  экранирование  спецсимволов
'\n', '\t', '\r', '\\'' и '\\"'. Также существует конструкция, позволяющая ввести в
строку символ с любым кодом - '\xhh', где hh - обязательно две шестнадцатеричные
цифры, образующие вместе однобайтовый код символа в диапазоне от 0 ('\x00') до 255
('\xff').

  Примеры строк в Муфлоне:

		"hello"  
		'world'  
		'long string with a double quote " inside'  
		"another long string with a single quote ' inside"  
		"string with a double quote \" inside"  
		'string with a single quote \' inside'  
		'string with \x30 a hex code \82 inside'  

  '', "" — пустые строки. Строки в языке Муфлон — неизменяемые.
  
* Логические константы и None.  
  Кроме   строковых  и   целочисленных   значений   язык   Муфлон   поддерживает
логические             значения             True             и            False.
Есть  также  специальное  значение  None,  выполнющее  функцию  пустого значения
(пустого   указателя).   Обратите   внимание,  логические  константы  пишутся  с
большой буквы.

* Комментарии.  
  Муфлон  поддерживает  однострочные  комментарии,  начинающиеся  с  символа  \#.
Весь     следующий    текст    до    конца    текущей    строки    игнорируется.
\# внутри строк считается обычным символом.

		# это комментарий  
		x = 5 #это тоже комментарий  
		# в следующей строке # - обычный символ  
		hashtag = "#природа" 

* Идентификаторы.  
  Идентификаторы  в  Муфлоне   используются  для  обозначения  имён  переменных,
классов   и   методов.  Правила  именования  идентификаторов  такие  же,  как  в
большинстве   других   языков   программирования:  начинаются  со  строчной  или
заглавной   латинской   буквы   либо  с  символа  подчёркивания.  Потом  следует
произвольная   последовательность,   состоящая   из   цифр,   букв   и   символа
подчёркивания.  
  Примеры   правильных   идентификаторов:   x,   _42,   do_something,   int2str.
Примеры                       неправильных                      идентификаторов:
4four   —   начинается   с   цифры;   one;two  —  содержит  символ,  который  не
относится к цифрам, буквам или знакам подчёркивания.

* Классы.  
  В Муфлоне можно  определить  свой  тип,  создав  класс.  Класс  имеет  поля  и
методы,    поля    не    надо    объявлять    заранее.    Объявление    поля   -
первое  его  применение.  Объявление   класса   начинается  с   ключевого  слова
class, за которым следует идентификатор имени и объявление методов класса.

  Пример класса «Прямоугольник»:

        class Rect:
          def __init__(w, h):
            self.w = w
            self.h = h
        
          def area():
            return self.w * self.h 

* Важные особенности классов в Муфлоне:  
  Специальный     метод     \_\_init\_\_     играет   роль   конструктора  —  он
автоматически       вызывается       при       создании      нового      объекта
класса.       Метод       \_\_init\_\_       может       отсутствовать.      Неявный
параметр     всех     методов    —    специальный    параметр    self,    аналог
указателя    this    в    C++.    Параметр    self    ссылается    на    текущий
объект   класса.   Поля   не   объявляются   заранее,  а  добавляются  в  объект
класса   при   первом   присваивании.   Поэтому   обращения   к   полям   класса
всегда    надо    начинать   с   self.,   чтобы   отличать   их   от   локальных
переменных. Все поля объекта — публичные.

  Новый объект ранее  объявленного  класса  создаётся  указанием  имени  класса,
  за которым в скобках идут параметры, передаваемые методу \_\_init\_\_.

        r = Rect(10, 5)

  В этой программе  создаётся  новый  объект  класса  Rect.  При  вызове  метода
  \_\_init\_\_  параметр  w  будет  иметь  значение  10,  а  параметр h — 5. Созданный
  прямоугольник будет доступен в переменной r.

* Типизация.  
  Муфлон — это  язык  с  динамической  типизацией.  В  нём тип каждой переменной
определяется   во  время  исполнения  программы  и  может  меняться  в  ходе  её
работы.   Поэтому  какие-либо  механизмы  явного  указания  типа  переменной  не
требуются.

  Пример:

		x = 4  # переменная x связывается с целочисленным значением 4  
		# следующей командой переменная x связывается со значением 'hello'  
		x = 'hello'  
		y = True  
		x = y 

* Массивы.  
  Кроме упомянутых выше скалярных переменных, в языке предусмотрена специальная
поддержка массивов - способа группового хранения однородных переменных под одним
именем, доступ к каждой из которых выполняется указанием набора её порядковых
номеров (или координат). Размерность и количество элементов многомерных массивов
могут быть указаны сразу при их создании (аргументами конструктора), и могут быть
переопределены позже, с помощью специального метода.
При переописании массива всё его содержимое теряется.Исключением из этого правила
являются одномерные массивы, размер которых можно изменить с сохранением их
содержания. Кроме того, для одномерных векторов определены несколько
дополнительных методов, позволяющих динамически выполнять над ними некоторые
специальные операции.  
  Синтаксис объявления массива использует специальное ключевое слово array и
выглядит так:

        arr_1d = array(5) # arr_1d - одномерный массив с пятью элементами  
        arr_2d = array(6, 7) # arr_2d - двумерный массив с шестью строками и
        # семью столбцами
        arr_3d = array(3, 4, 5) # трехмерный массив, содержащий три плоскости,
        # в каждой из которых содержатся четыре строки с пятью элементами в каждой.

  То есть array можно рассматривать как имя особого предопределённого класса,
  аргументы же его конструктора задают размерность массива (определяется количеством
  аргументов) и количество его элементов (задаётся значениями этих аргументов).  
  Такая форма описания неслучайна. В Муфлоне массив внутренне действительно
  организован как специальный встроенный класс с фиксированным набором собственных
  методов, состав которых постоянен и не подлежит изменению программистом. Эти
  методы обеспечивают основные сценарии доступа к элементам массива.  
  Вот полный список методов, предоставляемых классом массива:

    + get(... indexes ...) - служит для считывания и установки значения элемента
    массива, определенного набором координат-индексов. Все индексы базируются к
    нулю (минимальный индекс элемента для каждой размерности равен 0).
    + get_array_dimensions() - получение количества измерений массива.
    + get_dimension_count(index_number) - получение количества элементов
    для размерности, определяемой аргументом index_number. Номер размерности
    базируется к 1 (младший индекс и соответствующая размерность имеют номер 1).
    + resize(... counters ...) - пересоздание массива с иной размерностью и
    количеством элементов.
    + clear() - очистка массива. Удаление всей содержащейся в нём информации.
    Метод немного по-разному исполняется для одномерных и многомерных массивов.
    Размер одномерного массива при выполнении операции clear() уменьшается до
    нуля, то есть после этого вызова количество элементов в нём (число элементов
    его единственной размерности) будет равно 0. Размеры многомерного массива
    при вызове clear() не изменяются, но все его элементы устанавливаются в None.    

  Следующие методы определены только для одномерных массивов. Применение их для
  многомерных массивов приводит к возникновению ошибки периода исполнения.

    + push_back(new_element) - добавляет элемент new_element в конец массива.
    + back() - позволяет считать или установить последний элемент массива.
    + pop_back() - удаляет из массива последний элемент.

  Примеры применения вышеперечисленных методов:
  
        # сначала поработаем с одномерным массивом
        arr_1d = array(5)
        arr_1d.get(2) = 1
        arr_1d.get(3) = "str"
        arr_1d.push_back(6)
        arr_1d.push_back("rts")
        print "arr_1d:", arr_1d.get_array_dimensions(), arr_1d.get_dimension_count(1)
        # команда выше выводит такую строку: arr_1d 1 5
        print arr_1d.get(3), arr_1d.get(5), arr_1d.back()
        # эта команда выведет следующее : str 6 rts
        print arr_1d.get(2), arr_1d.get(2) \* 2, arr_1d.get(2) \* 3
        # ну а тут будет получено такое : 1 2 3
        # далее некоторые эксперименты с многомерным (двумерным) массивом
        x = 3
        y = 2
        arr_2d = array(6, 7)
        arr_2d.get(x, y) = "STR"
        arr_2d.get(2, 1) = 21
        arr_2d.get(y, x) = "RTS"
        print "arr_2d:", arr_2d.get_array_dimensions()
        # команда выше выводит такую строку: arr_2d 2
        print arr_2d.get_dimension_count(1), arr_2d.get_dimension_count(2)
        # здесь будет следующее: 6 7
        print arr_2d.get(x, y), arr_2d.get(2, 3)
        # эта команда выведет следующее : STR RTS
        print arr_2d.get(2, 1), arr_2d.get(2, 1) \* 2, arr_1d.get(2, 1) \* 3
        # ну а тут будет получено такое : 21 42 63

  Так как Муфлон - язык с динамической типизацией, в одном массиве могут храниться
  переменные любых типов, на это не накладывается никаких ограничений. Некоторую
  озадаченность читателя может вызвать работа метода get при его использовании для изменения
  значений элементов массива. На самом деле это есть случай "косвенного присваивания",
  описанного в этом документе ниже.

* Ассоциативные массивы.  
  Кроме обычных порядковых массивов, доступ к элементам которых выполняется прямым вычислением
их положения в памяти по их числовым индексам за время O(1), Муфлон поддерживает также
ещё один вид массивов - ассоциативные (словари).
Здесь индексом элемента является его единственное строковое имя - ключ. В качестве индекса-ключа
может выступать Муфлон-выражение любого типа, так как оно будет преобразовано в текстовую строку
так, как это делают описанные ниже функция str и команда print. Доступ к ассоциативному массиву,
как и прежде, осуществляется с помощью постоянного набора методов.
  Объявление словаря выглядит так:
  
        map_var = map()
  
  То есть ассоциативный массив - встроенный класс по имени map. За его фасадом скрывается также
  стандартный библиотечный класс библиотеки STL C++ с таким же именем. Набор предоставляемых методов
  выглядит так:

    + insert(key, value) - вставка в массив элемента value с ключом key.
    + find(key) - чтение или изменение уже существующего элемента с ключом key. Вызов метода с
    ключом, отсутствующем в ассоциативном массиве, вызывает ошибку периода исполнения.
    + erase(key) - удаление элемента с ключом key.
    + contains(key) - проверка наличия элемента с ключом key.
    + clear() - очистка словаря. Удаление всех содержащихся в нём элементов.

            keyb = "ququ"
            map_var.insert(keyb, 32)
            if map_var.contains(keyb):
              print map_var.find(keyb)
              map_var.erase(keyb)
            if not map_var.contains(keyb):
              print "OK"
            else:
              print "Error"

  Также предусмотрено небольшое семейство методов, позволяющее обойти все существующие элементы
  словаря с помощью механизма, несколько напоминающего C++ - итераторы.

    + begin() - возврат итератора, указывающего на первый элемент массива.
    + next(iterator) - передвигает итератор iterator вперед, перенацеливая его
    на следующий элемент словаря.
    + previous(iterator) - передвигает итератор iterator назад, перенацеливая его
    на предыдущий элемент словаря.
    + is_iterator_begin(iterator) - возвращает True, если итератор указывает на
    первый элемент словаря.
    + is_iterator_end(iterator) - возвращает True, если итератор указывает __за__
    последний элемент словаря. Разыменование такого итератора недопустимо.
    + key(iterator) - возвращает ключ элемента, соответствующего iterator.
    + value(iterator) - чтение или изменение элемента, на который указывает iterator.
    + release() - сообщает об окончании процесса перечисления элементов словаря. После вызова
    этого метода словаря все его итераторы считаются невалидными и их использование закончится
    исключением времени исполнения.

  Если iterator некорректен, возникает ошибка периода исполнения. Аналогично закончится
  попытка разыменования (применения методов key() или value()) к итератору, указывающему __за__
  последний элемент ассоциативного массива. Проверяйте данное обстоятельство с помощью метода
  is_iterator_end().

            i = 0
            while i < 10:        
              map_var.insert(i, 2 * i)
              i = i + 1
              
            map_iter = map_var.begin()
            while not map_var.is_iterator_end(map_iter):
              print map_var.key(map_iter), map_var.value(map_iter)
              map_var.next(map_iter)
            map_var.release()

  На корректность операции обхода элементов накладывается следующее, весьма жесткое ограничение. В
  ходе всего процесса состав ключей словаря не должен меняться. То есть с момента получения "итератора"
  методом begin() и до завершения перечисления элементов вызовом release() накладывается строгий запрет
  на обращение к методам insert(key) и erase(key) соответствующего ассоциативного массива. Попытка
  сделать это приведёт к ошибке периода исполнения. Аналогичный результат получится при использовании
  любого итератора после вызова метода release().

* Объект математической коллекции.  
  Данный объект позволяет выполнять над числами некоторые математические операции. На данный момент
входят в коллекцию и поддерживаются следующие функции:

    + abs(arg) - модуль числа arg.
    + pow(arg, exp) - возведение числа arg в степень exp.
    + sqrt(arg) - извлечение квадратного корня из arg.
    + sin(arg) - синус arg.
    + cos(arg) - косинус arg.
    + atan(arg) - арктангенс arg.
    + atan2(y, x) - арктангенс y / x (аналог функции atan2() из STL C++).
    + log(arg) - натуральный логарифм arg.
    + exp(arg) - нтуральный антилогарифм - возведение в степень arg основания натуральных
    логарифмов e.
    + ceil(arg) - округление аргумента arg вверх. Возвращает целочисленный результат.
    + floor(arg) - округление аргумента arg вниз. Возвращает целый результат.
    + round(arg) - округление аргумента arg к ближайшему целому. Возвращает целый результат.

  Пример применения методов коллекции.

            i = 3.14159265 / 2
            j = i / 2
            mth = math()
            # Следующая операция выводит: 1 0.707107 1.7949e-09 0.707107
            print mth.sin(i), mth.sin(j), mth.cos(i), mth.cos(j)
            # Следующая операция выводит: 1 2
            print mth.floor(i), mth.ceil(i)

* Операции.  
  В Муфлоне определены:
  + Арифметические операции для целых чисел, деление выполняется нацело.
  Деление на ноль вызывает ошибку времени выполнения.
  + Арифметические операции для чисел с плавающей точкой. Деление на ноль
  также вызывает ошибку времени выполнения.
  + Побитовые операции для целых чисел. Среди них унарный комплемент (~),
  бинарные И (&), ИЛИ (|), исключающее ИЛИ (^), сдвиги влево (<<) и вправо
  (>>).
  + Эти же побитовые действия определены и для чисел с плавающей точкой.
  В этом случае операции выполняются прямо над их двоичным представлением,
  игнорируя внутреннее устройство таких дробных чисел.
  + Операция конкатенации строк, например: s = 'hello, ' + 'world'.
  + Побитовые операции над строками, которые выполняются над каждым символом
  (для унарной битовой операции ~) входной строки или каждой парой соответствующих
  символов (для бинарных операций) двух входных строк независимо.
  + Операции сравнения строк и целых чисел ==, !=, <=, >=, <, >; сравнение
  строк выполняется лексикографически.
  + Логические операции and, or, not.
  + Унарный минус.
  
  Приоритет операций (в порядке убывания приоритета):
  + Унарный минус и побитовое дополнение.
  + Умножение, деление и остаток от деления.
  + Сложение и вычитание.
  + Побитовые сдвиги влево и вправо.
  + Побитовое И, ИЛИ и исключающее ИЛИ.  
  + Операции сравнения.
  + Логические операции.

  Как видите, система приоритета тут несколько отличается от C/C++, она существенно
  проще и в ней куда меньше ступеней. Кроме того, побитовая логика тут более приоритетна,
  чем сравнительные действия.

  Порядок вычисления выражений может быть изменён скобками:

        print 2 + 3 * 4   # выведет 14
        print (2 + 3) * 4 # выведет 20 

    В  Муфлоне  операция  сложения  кроме  чисел  и  строк  применима  к  объектам
  классов со специальным методом \_\_add__:

        class Fire:
          def __init__(obj):
            self.obj = obj

          def __str__():
            return "Burnt " + str(self.obj)

        class Tree:
          def __str__():
            return "tree"

        class Matches: # Спички
          # операция сложения спичек с другими объектами превращает их в огонь
          def __add__(smth):
            return Fire(smth)

        result = Matches() + Tree()
        print result             # Выведет Burnt tree
        print Matches() + result # Выведет Burnt Burnt tree 

    Операции  сравнения  применяются  не  только  к  числам  и  строкам,  но  и  к
  объектам   классов,   имеющих   методы   \_\_eq__   (проверка  «равно»)  и  \_\_lt__
  (проверка   «меньше»).   Используя   эти   методы,   релизуются   все   операции
  сравнения.

      class Person:
        def __init__(name, age):
          self.name = name
          self.age = age
        def __eq__(rhs):
          return self.name == rhs.name and self.age == rhs.age
        def __lt__(rhs):
          if self.name < rhs.name:
            return True
          return self.name == rhs.name and self.age < rhs.age
      
      print Person("Ivan", 10) <= Person("Sergey", 10) # True
      print Person("Ivan", 10) <= Person("Sergey", 9)  # False 

* Функция str.  
  Функция str преобразует  переданный  ей  аргумент  в  строку.  Если аргумент —
объект  класса,  она  вызывает  у  него  специальный  метод \_\_str__ и возвращает
результат.  Если  метода  \_\_str__  в  классе  нет,  функция возвращает строковое
представление адреса объекта в памяти.

  Примеры:

      str('Hello') вернёт строку Hello;
      str(100500) вернёт строку 100500;
      str(False) вернёт строку False;
      str(Rect(3, 4)) вернёт адрес объекта в памяти, например 0x2056fd0.
      
      Пример класса с методом __str__:
      class Rect(Shape):
        def __init__(w, h):
          self.w = w
          self.h = h
      
        def __str__():
          return "Rect(" + str(self.w) + 'x' + str(self.h) + ')' 

  Выражение str(Rect(3, 4)) вернёт строку Rect(3x4).

* Команда print.  
  Специальная   команда   print    принимает   набор   аргументов,   разделённых
запятой,  печатает  их  в  стандартный  вывод  и  дополнительно  выводит перевод
строки. Посмотрите на этот код:

      x = 4
      w = 'world'
      print x, x + 6, 'Hello, ' + w 

  Он выведет:  
  4 10 Hello, world 

  Команда  print вставляет  пробел  между  выводимыми  значениями.  Если  ей  не
  передать  аргументы,  она  просто  выведет  перевод  строки. Чтобы преобразовать
  каждый  свой  аргумент  в  строку,  команда  print  вызывает  для  него  функцию
  str.  Таким  образом,  команда  print  Rect(20,  15)  выведет  в  stdout  строку
  Rect(20x15).

* Условный оператор.  
  В Муфлоне есть условный оператор. Его синтаксис:

      if <условие>:
        <действие 1>
        <действие 2>
        ...
        <действие N>
      else:
        <действие 1>
        <действие 2>
        ...
        <действие M> 

  <условие>   —   это   произвольное  выражение,  за  которым  следует  двоеточие.
  Если  условие  истинно,  выполняются  действия  под  веткой  if,  если  ложно  —
  действия   под   веткой   else.  Наличие  ветки  else  необязательно.  <условие>
  может   содержать  сравнения,  а  также  логические  операции  and,  or  и  not.
  Условие  будет  истинным  или  ложным  в  зависимости  от  того, какой тип имеет
  вычисленное выражение.  
  Если  результат  вычисления   условия   —   значение   логического  типа,  для
  проверки истинности условия используется именно оно.

  Примеры:

        if x > 0:
        if s != 'Jack' and s != 'Ann':

  Если  результат  вычисления   условия   —   число,  условие  истинно  тогда  и
  только тогда, когда это число не равно нулю.

  Если  результат  вычисления   условия   —  строка,  условие  истинно  тогда  и
  только   тогда,   когда   эта  строка  имеет  ненулевую  длину.  Если  результат
  вычисления   условия   —   объект   класса,   условие  истинно.  Если  результат
  вычисления условия — None, условие ложно.

  Действия в ветках  if  и  else  набраны  с  отступом  в два пробела. Вообще, в
  языке   Муфлон  команды  объединяются  в  блоки  отступами.  Один  отступ  равен
  двум    пробелам.    Отступ    в    нечётное   количество   пробелов   считается
  некорректным.

  Сравните:

        if x > 0:
          x = x + 1
        print x

        if x > 0:
          x = x + 1
          print x 

  Первая команда print  x  будет  выполняться  всегда,  вторая  —  только если x
  больше 0. Вложенность условий может быть произвольной:

        if x > 0:
          if y > 0:
            print "Эта строка выведется, если x и y положительные"
        else:
          print "Эта строка выведется, если x <= 0" 

* Оператор цикла while.  
  Муфлон включает в свой состав также обычный универсальный оператор цикла с
предусловием. Его синтаксис выглядит так:

        while <условие>:
          <действие 1>
          <действие 2>
          ...
          <действие N>

  Участок кода, входящий в блок цикла (набранный с отступом в два пробела), будет
  выполняться многократно, пока <условие> будет истинным. Правила вычисления условия
  аналогичны таковым в операторе if и описаны выше. Предусмотрены также две дополнительных
  команды, позволяющих досрочно перейти к следующей итерации цикла, а также немедленно
  прервать его исполнение. Для перехода к следующей итерации служит команда continue,
  а для досрочного завершения цикла - команда break.
    
    + break    
      
      Команда break немедленно завершает цикл. Ниже приведен типичный способ её
      применения:
    
            while <условие 1>:
              <действие 1>
              if <условие 2>:
                break
              <действие 2>
            
            <действие 3>
        
      Если при выполнении оператора if <условие 2> это условие будет вычислено как
      истинное, то последующее выполнение команды break приведет к немедленному выходу
      из цикла и передаче управления на <действие 3>.
    
    + continue

            while <условие 1>:
              <действие 1>
              if <условие 2>:
                continue
              <действие 2>
            
            <действие 3>

      В случае, если при выполнении оператора if <условие 2> окажется истинным, то
      то при дальнейшем исполнении команды continue управление тут же будет передано
      в начало цикла к точке проверки истинности <условия 1>. И если оно также будет в
      этот момент истинным, то выполнение цикла продолжится как обычно, с <действия 1>.
      Если же <условие 1> вычислится как ложное, то работа цикла прекратится и
      управление будет передано за его пределы, к <действию 3>.

* Наследование.  
  В  языке  Муфлон  у  класса  может  быть  один  родительский  класс.  Если  он
есть,  он  указывается  в  скобках  после  имени  класса и до символа двоеточия.
В примере ниже класс Rect наследуется от класса Shape:

        class Shape:
          def __str__():
            return "Shape"

          def area():
            return 'Not implemented'

        class Rect(Shape):
          def __init__(w, h):
            self.w = w
            self.h = h

          def __str__():
            return "Rect(" + str(self.w) + 'x' + str(self.h) + ')'

          def area():
            return self.w * self.h 

  Наследование в языке  Муфлон,  как  и  ожидается,  приводит  к  тому,  что все
  методы   родительского  класса  становятся  доступны  классу-потомку.  При  этом
  все   методы   публичные  и  виртуальные.  Например,  код  ниже  выведет  Hello,
  John:

        class Greeting:
          def greet():
            return "Hello, " + self.name()

          def name():
            return 'Noname'

        class HelloJohn(Greeting):
          def name():
            return 'John'

        greet_john = HelloJohn()
        print greet_john.greet() 

* Методы.  
  Как вы могли заметить, методы в Муфлоне имеют синтаксис:

        def <имя метода>(<список параметров>):
          <действие 1>
          <действие 2>
          ...
          <действие N> 

  Ключевое  слово def  располагается  с  отступом  в  два  пробела  относительно
  класса.  Инструкции,  составляющие  тело  метода,  имеют  отступ  в  два пробела
  относительно  ключевого  слова  def.  Как  и  в случае полей класса, обращения к
  полям и методам текущего класса надо начинать с self.:

        class Factorial:
          def calc(n):
            if n == 0:
              return 1
            return n * self.calc(n - 1)

        fact = Factorial()
        print fact.calc(4) # Prints 24 

  Этот пример  представляет  собой, наверное,  самую  распространённую функцию,
  применяемую  в  информатике для демонстрации   механизма   рекурсии - факториал
  (наряду с расчётом чисел Фибоначчи). Команда return завершает выполнение метода
  и возвращает из него результат вычисления своего аргумента.   Если   исполнение
  метода  не  достигает  команды  return,  метод возвращает None.

* Семантика присваивания.  
  Как сказано выше,  Муфлон  —  это  язык  с  динамической типизацией, и все его
переменные   являются   указателями   на   области   памяти,   где  хранятся  их
действительные  на  момент  исполнения  инструкции  значения.  Поэтому  операция
присваивания  имеет  семантику  не  копирования  значения  в  область  памяти, а
изменения    адреса,   на   который   указывает   переменная.   Как   следствие,
переменные  только  ссылаются  на  значения,  а  не  содержат  их  копии. Пустой
(нулевой)   указатель   —   значение   None.   Код   ниже  выведет  2,  так  как
переменные x и y ссылаются на один и тот же объект:

        class Counter:
          def __init__():
            self.value = 0

          def add():
            self.value = self.value + 1

        x = Counter()
        y = x
        x.add()
        y.add()
        print x.value 

* Косвенное присваивание.  
  Муфлон  поддерживет  также   особенную  форму  присваивания,  которую   можно
назвать "косвенным".  
Такое  присваивание  случится,  если  левая часть оператора присваивания  будет
являться  вызовом  какого-нибудь метода, который возвратит значение особого рода -
так называемую ссылку.  Ссылка - это специальный внутренний объект языка,
указывающий не на область памяти, непосредственно хранящую значение, а на
некоторое поле собственного объекта.  
Такую ссылку можно рассматривать как аналог указателя на это поле (а с учётом
описанного выше  принципа  хранения переменных в языке, даже как указатель на
указатель).  
Для  данной  конструкции  при  дальнейшем исполнении операции  присваивания эта
переменная (целевое поле ссылки) будет перенацелена на ту область памяти, на
которую указывает вычисленная правая часть оператора косвенного присваивания.  
Для возврата из метода ссылки на какое-либо поле  служит специальная команда
return_ref. Вот комплексный пример применения описываемой схемы:

        class Rect(Shape):
          def __init__(w, h):
            self.w = w
            self.h = h

          def get_w():
            return self.w

          def get_h():
            return self.h

          def get_w_ref():
            return_ref self.w

          def get_h_ref():
            return_ref self.h

        x_rect = Rect(10, 20)
        print x_rect.w, x_rect.h # Эта команда выведет: 10 20
        x_rect.get_w_ref() = 100
        x_rect.get_h_ref() = 200
        print x_rect.w, x_rect.h # Эта команда выведет: 100 200

  Фактически, это есть некоторая очень ограниченная поддержка указателей, обеспечивающая
  простейшие способы их применения, но позволяющая при этом избежать большинства возникающих
  с ними проблем безопасности. В частности, ссылку можно вернуть только на поле объекта,
  возврат ссылок на локальные переменные метода или временные значения не допускается.
  То есть такое применение return_ref вызовет ошибку синтаксического разбора:

        def get_tmp_ref():
          temp = 1
          return_ref temp # Ошибка! Попытка возврата указателя на локальную переменную.

  Хранение полученной ссылки тоже невозможно, её можно только немедленно использовать
  в том же операторе. Если метод, возвращающий ссылку, используется в правой части оператора
  присваивания, то его результат автоматически "разыменовывается", то есть вместо ссылки
  будет подставлено значение соответствующей переменной. То есть конструкция

        a = x_rect.get_w_ref()
        b = x_rect.get_h_ref()

  равносильна вот такой:

        a = x_rect.get_w()
        b = x_rect.get_h()

  Все это в целом позволяет избежать основной уязвимости, связанной со ссылками - проблемы
  "висячего указателя" и несоответствия времени жизни ссылки и её целевого объекта.

* Прочие ограничения.  
  Результат  вызова  метода   или   конструктора   в   Муфлоне   —  терминальная
операция.  Её  результат  можно  присвоить  переменной  или  использовать в виде
параметра   функции   или   команды,   но   обратиться   к   полям   и   методам
возвращённого объекта напрямую нельзя:

        # Так нельзя
        print Rect(10, 5).w
        # А вот так можно
        r = Rect(10, 5)
        print r.w 

Способ запуска программ интерпретатором.
----------------------------------------

  Для исполнения программы  на  языке  Муфлон  описываемым  интерпретатором  она
должна быть подвергнута последовательно следующим стадиям преобразования:

1. Лексический разбор.
2. Синтаксический  анализ.  В  результате  его  будет  построено  синтаксическое
дерево программы.
3. Непосредственно исполнение дерева, построенного на предыдущем шаге.

Так всё это выглядит, собственно, в коде:

        parse::TrivialParseContext parse_context();
        runtime::SimpleContext context(output);
        runtime::Closure closure;

        parse::Lexer lexer(input);  // лексический разбор
        auto program = ParseProgram(lexer, parse_context); // синтаксический анализ
        program->Execute(closure, context); // исполнение

  Входному   лексическому   анализатору    parse::Lexer   программа   передаётся
через     какой-либо     стандартный     поток,     приводимый     к    istream.
Результат   работы   лексического   разборщика  передаётся  для  синтаксического
анализа  через  параметр  функции  ParseProgram,  возвращающей  объект корневого
узла  абстрактного  синтаксического  дерева  программы.

  Для корректного выполнения синтаксического анализа требуется вспомогательный
объект - разборочный контекст parse_context. Он обслуживает исполнение некоторых
директив трансляции (пока только import) и хранит список задействованных программой
общесистемных ресурсов. Так как программа после синтаксического разбора представляет
собой систему размещённых в куче взаимосвязанных узлов, порядок уничтожения которых
при выходе программы из области видимости очень слабопредсказуем, то, к сожалению,
высвободить захваченные системные ресурсы объекты программы самостоятельно не могут.
Поэтому это придётся сделать вам самостоятельно, обратившись к особому методу
DeallocateGlobalResources() этого объекта.

  Но учтите, что это можно сделать только тогда, когда дерево программы program
уже уничтожено и более не существует. Если такое высвобождение требуется, следует
обеспечить большую  продолжительность существования parse_context по сравнению с
program. Пока единственным таким видом системных ресурсов являются динамические
разделяемые библиотеки "втыкал" (о втыкалах рассказано далее).

  Вы можете повлиять на алгоритм обработки директив трансляции, написав собственную
реализацию разборочного контекста, совместимую с ним по интерфейсу, и передав её
синтаксическому  анализатору. Для  этого  ваш  объект  следует  унаследовать  от
parse::ParseContext. Если же стандартный алгоритм вас устраивает и высвобождение
упомянутых выше ресурсов не требуется, то разборочный контекст можно вовсе не
создавать - он будет создан автоматически особой перегруженной функцией ParseProgram
и сразу уничтожен при завершении синтаксического анализа. Для этого процедуру
подготовки и исполнения Муфлон-программы можно произвести так:

        runtime::SimpleContext context(output);
        runtime::Closure closure;

        parse::Lexer lexer(input);  // лексический разбор
        auto program = ParseProgram(lexer); // синтаксический анализ
        program->Execute(closure, context); // исполнение

  Как было указано ранее, функция ParseProgram возвращает указатель на корневой
узел синтаксического дерева разобранной программы. Вызывая же метод Execute этого
узла (он есть у каждого узла построенного дерева), запускаем программу на
исполнение. Исполнение программы, таким образом, представляет собой синтаксически
управляемый обход узлов этого дерева. Аргументами же метода Execute служат таблица
символов программы closure и вспомогательная переменная context, хранящая состояние
исполнительской среды. Этот  контекст служит цели хранения некоторых параметров и
обеспечения исполнения отдельных операторов языка.

  Таким  оператором,  является,  в  частности,  команда  print.  Она  направляет
весь   свой   вывод   в   какой-либо   выходной  поток,  приводимый  к  ostream.
Конкретный поток, который будет использовать print, хранится в контексте.
  
  Создать  нужный  контекст   можно  с  помощью  класса  runtime::SimpleContext,
который   представляет   один   из   видов   такого   контекста,  совместимый  с
методами   Execute   синтаксического   дерева.  Его  конструктор  принимает  два
аргумента   -   выходной   поток   для   print  и  необязательный  указатель  на
функцию,  которая  будет  служить  каналом  обмена  информацией для специального
объекта \_\_external (в приведённом примере он не показан).

Разделение программы на модули уровня исходного текста.
-------------------------------------------------------

  Муфлон-программу можно разделить на несколько исходных модулей. Объединение их
в единый программный комплекс выполняется при синтаксическом разборе с помощью
директивы include.

        # include - директива включения исходного модуля module_name
        # по месту её расположения.
        include "module_name"

  Работа её вполне интуитивна и типична - можно полагать, что модуль с именем
module_name целиком включается в ту точку, где расположена директива include.

  Данная инструкция - это именно директива, а не команда языка, и она обрабатывается
до начала исполнения программы, в процессе подготовки её у исполнению - синтаксического
анализа. Поэтому её единственным обязательным аргументов может быть только строковая
константа.

  Однако, реализация работы этой директивы весьма нетривиальна и требует от программиста,
задействующего данный интерпретатор в своей разработке, отдельных специальных усилий. Как
можно видеть из приведённого выше кода, передача исходного кода лексическому анализатору
транслятора осуществляется не на уровне файлов, а с помощью более высокого уровня
абстракции - на уровне абстрактных потоков ввода. Поэтому обработать директиву include
полностью самостоятельно разборщик не может. Это должна сделать внешняя среда, включающая
в себя интерпретатор, а он может оказать ей в этом лишь некоторую поддержку.

  Для этого объект лексического разборщика parse::Lexer имеет дополнительный конструктор,
который можно использовать для его создания вместо описанного выше. Сигнатура этого
конструктора выглядит так:

        explicit Lexer(LexerInputEx& input);

где LexerInputEx - специальный абстрактный класс, конкретного наследника которого нужно
реализовать программисту, использующему интерпретатор Муфлона, чтобы сделать директиву
include функциональной (по умолчанию она просто игнорируется). Данный класс представляет собой
упрощённый аналог потока ввода istream, функциональности которого достаточно дя работы лексициста
Lexer интерпретатора Муфлона. Кроме набора стандартных функций-членов потока, он содержит
два специальных метода:

        void IncludeSwitchTo(std::string include_arg);
        void SetCommandDescPtr(runtime::ProgramCommandDescriptor* command_desc_ptr);

с помощью которых и будет выполняться вся работа по переключению исходных модулей программы
по директиве include.

  Перед пользовательской реализацией класса LexerInputEx стоят две задачи. Первая - предоставление
интерпретатору нужной входной информации (исходного кода транслируемой программы) через собственные
функции-члены. К таким функциям относятся методы get(), peek() и unget(), служащие для
непосредственного считывания данных, а также функции operator bool(), operator!() и good(),
предназначенные для получения информации о состоянии потока. Семантика всех этих функций-членов
полностью совпадает с таковыми функциями обыкновенного потока класса istream.

  Вторая задача - снабжать интерпретатор информацией о его текущем положении внутри многомодульного
проекта, обеспечивать ядро транслятора некоей ориентировкой относительно координат обрабатываемой
в данный момент точки исходного кода. Эта информация не является необходимой для, собственно,
трансляции, но будет использоваться для поддержки работы внешнего отладчика, диагностики и выработки
информативных сообщений об ошибках с указанием их точного места.

  Для решения первой задачи взаимодействие ядра интерпретатора и пользовательского класса LexerInputEx
выглядит следующим образом. Перед началом обработки проекта транслятор однократно вызовет метод
LexerInputEx::IncludeSwitchTo с пустой строкой-аргументом include_arg (инициализирующий вызов).
По этому вызову класс должен внутренне настроиться на отдачу через свои потоковые функции начального
модуля программы.

  Далее при каждой встрече с директивой include данный метод будет вызван синтаксическим разборщиком
вновь, но на этот раз через параметр include_arg ему будет передан её параметр module_name. После
такого вызова класс LexerInputEx должен переключиться на отдачу модуля с соответствующим именем.

  Система директив include может быть неограниченно вложенной (но не допускать прямой или косвенной
рекурсии), поэтому классу LexerInputEx следует поддерживать внутренюю стекообразную структуру,
содержащую полную информацию о текущем состоянии иерархии включения модулей друг в друга, чтобы
иметь возможность после завершения текущего модуля возвращаться вверх по её иерархии. После достижения
конца текущего модуля класс LexerInputEx должен самостоятельно возвратиться к тексту модуля более
высокого уровня вложенности в ту его точку, которая непосредственно следует за строкой с директивой
include. Это должно происходить автоматически, полностью прозрачно для ядра интерпретатора.

  При невозможности затребованного переключения либо возникновении ошибки в ходе данного процесса,
метод IncludeSwitchTo должен швырнуть исключение класса ParseError, поле what которого (является
единственным аргументом конструктора класса ParseError) должно содержать понятное сообщение о
сущности и причине произошедшего аварийного события.

  Для решения второй задачи также, как и ранее, перед началом трансляции проекта, ядро интерпретатора
единожды вызовет функцию-член LexerInputEx::SetCommandDescPtr. Её аргумент - указатель на внутреннюю
структуру транслятора, имеющую тип runtime::ProgramCommandDescriptor. Это простая структура, содержащая
всего два поля:

        namespace runtime
        {
            struct ProgramCommandDescriptor
            {
                int module_id;
                int module_string_number;
            };
        }

module_id - условный номер каждого модуля. Требуется обеспечить его уникальность в пределах каждой
программы (многомодульного проекта). Присваивание таких номерных идентификаторов модулям выполняется
классом-наследником LexerInputEx самостоятельно, МУФЛОН-интерпретатор в этот вопрос не вмешивается.
Он только считывает это поле, но никогда ничего в него не записывает.

  Поле module_string_number - номер строки внутри модуля. Этот номер базируется к нулю (номер начальной
строки любого модуля равен 0). Вычисление этого поля выполняется совместно классом-наследником
LexerInputEx и ядром интерпретатора следующим образом. Переход к следующей строке каждого модуля
фиксируется транслятором самостоятельно, каждый раз при таком переходе значение поля module_string_number
увеличивается на единицу. Изменения же данного номера при переключении модулей должен выполнить класс
LexerInputEx. При переключении модулей по директиве include следует сохранить его текущее значение
в упомянутой выше стековой структуре описания вложенности, а затем сбросить это поле в нуль.
При обратном же возвращении в модуль (когда модуль-вставка завершился) его нужно просто восстановить
из этой стековой структуры.

  Это наиболее рациональный способ работы с содержимым класса ProgramCommandDescriptor. Но так как
конкретные значения полей этой структуры никак не влияют на сам процесс трансляции, а служат только
целям информирования отладчика и для формирования сообщений об ошибках, то, в принципе, можно хранить
в них произвольные значения и изменять их любым способом.

  Как указано выше, первоначальные инициализирующие вызовы методов SetCommandDescPtr И IncludeSwitchTo
делаются перед началом непосредственной трансляции исходного кода программы. На данный момент такие
вызовы выполняются прямо из тела конструктора лексического разборщика - объекта класса Lexer. Но хотя
в дальнейшем это обстоятельтво может измениться, гарантируется, что метод SetCommandDescPtr всегда будет
вызываться раньше, чем произойдёт начальное обращение к функции-члену IncludeSwitchTo.

  Любая реализация класса-наследника абстрактного класса LexerInputEx, удовлетворяющая этим, весьма
общим требованиям по взаимодействию с интерпретатором, может использоваться как источник исходного
текста МУФЛОН-программы. Все остальные детали реализации и конкретные действия по хранению,
переключению и диспетчеризации модулей будут определяться только внутренним устройством этого
конкретного класса и самого интерпретатора уже не касаются.

  К   комплекту   поставки   приложены  два   примера  такого  типа.  В   состав
основного    проекта    в   качестве    одного  из   модульных  тестов  (функция
TestIncludes())   входит    многчастная   Муфлон-программа,   фрагменты  которой
хранятся   в   виде  отдельных строковых  выражений типа string. Для обеспечения
работы   этой    системы    реализован    простейший   диспетчер  модулей  класс
LexerInputExImpl,   представляющий   собой  конкретного  наследника абстрактного
класса-интерфейса   LexerInputEx.   Изучение   его   устройства   даст  вам  всю
необходимую    информацию    для  создания   собственных   аналогичных  классов,
выполняющих   такие   же   функции   для  других  способов  хранения  фрагментов
исходного текста многомодульной программы.

  Второй пример - самостоятельный проект MythonInclude. В нём фрагменты хранятся уже более традиционно - 
как отдельные файлы. Для этого там реализован класс LexerFileInputExImpl, изучение которого тоже может
быть весьма полезно.

Возможные области практического применения языка.
-------------------------------------------------

  Как    следует    из    вышеприведённого    описания,    возможности    языка
оставляют    весьма    двойственное   впечатление.   Безусловно,   его   нельзя
рассматривать  как  средство  разработки  крупных  программных  комплексов. Это
связано   как  с  ограничениями  самого  языка,  так  и  с  текущим  состоянием
исполнительской среды - предлагаемого интерпретатора.

  К  первым  относятся   прежде   всего  ограниченность  его  объектной  модели
и  механизмов,  которые,  вообще  говоря,  не обеспечивают выполнение принципов
ООП    в   части   инкапсуляции   классов   и   распределения   полномочий   на
использование   их   полей   и   методов.   Без  существенного  изменения  всех
внутренних   механизмов   трансляции   устранить   это  обстоятельство  нельзя,
поэтому с ним придётся примириться.

  Второй    крупный   и     фундаментальный     неустранимый    недостаток    -
принципиальная  однопоточность   хода   исполнения  программ.  При  принятых  в
интерпретаторе   архитектурных    решениях    обеспечить    наличие   в   языке
каких-либо    видов     многопоточности     и     асинхронности     тоже     не
представляется возможным.

  Все остальные недостатки следует отнести к преходящим и в ближайшее время они,
так или иначе, будут исправлены. Среди таких можно указать главный: со стороны
интерпретатора не обеспечивается какая-либо поддержка обычных техник отладки
программ или вспомогательного сервиса для внешнего отладчика.

Всё это  очерчивает возможную  на  данный  область  применения  этого  языка -
встроенный  язык  простых  сценариев  для  какой-либо  иной программной системы.
Но  для  этого  нужно  предусмотреть  механизмы  взаимодействия интерпретатора с
объемлющим   комплексом,   в   который   он   будет   включён.   Описанию  таких
механизмов посвящён следующий небольшой раздел.

Взаимодействие интерпретатора языка Муфлон с внешней средой.
------------------------------------------------------------

  Взаимодействие     интерпретатора    с     внешней     программой     возможно
четырьмя основными способами. К ним относятся:

*  создание   нестандартного  потока  вывода.
*  применение специального системного объекта \_\_external.
*  подключение двоичного дополнения - "втыкалы" - оформленного как стандартная
   системная разделяемая библиотка, предоставляющая специальный набор экспортируемых функций,
   обеспечивающих взаимодействие втыкалы с ядром исполнительной среды.
*  внесение изменений и дополнений в исходный код интерпретатора.

  Первые три из них уже внутренне предусмотрены в интерпретаторе, не требуют
изменения его исходного кода и осуществляются путём предоставляемых им интерфейсов. 

  Для применения первых двух способов задействуется специально сформированный
контекст исполнения программы, в котором хранятся все необходимые для этого
сведения.

### Создание  нестандартного  потока  вывода.

  Нестандартный, пользовательский выходной поток должен быть приводим к ostream
и будет получать весь вывод команды print. Метод-получатель информации внутри 
такого потокового объекта, получая данные из программы на Муфлоне, может в
соответствии с ними предпринимать любые действия по своему усмотрению. Простой
пример такого взаимодействия приведён в приложенной к проекту демонстрационной
программе NonStdPrint.cpp.

### Применение специального системного объекта \_\_external.

  Второй     канал     обмена      информацией     с     Муфлон-программой -
использование    специального    объекта   \_\_external. Любое обращение к его
полям или методам сопровождается вызовом указанной пользователем звонковой
функции ("функции обратного вызова"). Если при создании SimpleContext
использовать  двухоперандный вариант  конструктора,  то  второй операнд будет
указывать на функтор (любой   вызываемый   объект) типа LinkageFunction,
определённый так:

        namespace runtime
        {
            enum class LinkCallReason
            {
                CALL_REASON_UNKNOWN = 0,
                CALL_REASON_READ_FIELD,
                CALL_REASON_WRITE_FIELD,
                CALL_REASON_CALL_METHOD
            };

            using LinkageValue = variant<monostate, bool, int, double, string>;
            using LinkageFunction = function<LinkageValue(LinkCallReason,
                                    const string&, const vector<LinkageValue>&)>;
            .................................
        }

Эта функция принимает три аргумента:

1. Тип  операции  -  перечисление LinkCallReason - оно указывает  причину вызова
функции:  этот  параметр  принимает  значение CALL_REASON_WRITE_FIELD при записи
в  какое-либо  поле  объекта, CALL_REASON_READ_FIELD  при  чтении  из  него и 
CALL_REASON_CALL_METHOD при сигнализации о вызове какого-либо его метода.

2. Имя поля или метода.

3. Массив (вектор) значений типа LinkageValue, содержащий данные, которые являются
входными аргументами операции. Количество и смысл элементов этого вектора зависит от
конкретного типа операции, повлекшей за собой вызов звонковой функции LinkageFunction.  
  Так, при выполнении операции записи в поле объекта класса \_\_external такой аргумент
будет только  один - собственно,  то  значение, которое  должно быть  присвоено  полю.
Оно  будет  являться  нулевым элементом вектора.  
  Операция  чтения  из  поля  вовсе не имеет входных аргументов, поэтому для неё
вектор будет пуст.  
  Если "обратный звонок" ассоциирован с вызовом какого-либо метода объекта класса
\_\_external, то элементы массива заполняются значениями всех его фактических
параметров. Они помещаются в массив в естественном порядке - в том, в котором они
располагаются в списке входных аргументов метода.

  В  процессе  исполнения  программы   при любом  обращении  к  полям  и методам
объекта \_\_external (чтение или присваивание любых его полей, а также вызов любых
его методов)  будет  вызываться указанный   через   конструктор   контекста
SimpleContext  функтор,  аргументы которого заполняются описанным выше способом.

  При  осуществлении   операции  чтения   из   поля   объекта   функция   должна
вернуть некоторое значение. Это значение тоже имеет тип LinkageValue. Возвращенный
таким способом результат трактуется так:

1. Для операции чтения поля он будет считаться в программе текущим значением самого
этого поля.

2. При выполнении  записи  возвращаемое значение игнорируется.

3. При вызове функции, произведенном в связи с обращением к какому-либо методу
объекта \_\_external, возвращаемое значение функции трактуется аналогично случаю
чтения поля - рассматривается как значение, возвращенное этим методом.

Семантика типа LinkageValue также требует некоторых пояснений. Этот тип принадлежит
к вариантному библиотечному типу STL (std::variant). Он может содержать величины
различных типов, выбранных из набора, состоящего из пяти базовых типов C++: monostate,
bool, int, double, string. Последние четыре типа взаимно однозначно связаны с
определёнными внутренними типами значений (а также переменных) Муфлона, которые
обрабатываются в программах на этом языке. Первый же тип (monostate) эквивалентен
"пустому значению" None.

  Пример   использования    этого   механизма    приведён   в   демонстрационной
программе ExternalObjectDemo.cpp.

### Втыкалы.

  Третий способ - использование "втыкал". К комплекту поставки данной программы
приложены две таких втыкалы - тестовая, служащая для проверки работоспособности
самого механизма их подключения, а также втыкала, имеющая уже определённую практическую
ценность - обеспечивающая элементарное обращение к файловой системе с помощью
типовых функций ввода-вывода стандартной библиотеки языка C (stdio.h).

  Применение втыкал основано на том, что каждая из них предоставляет ядру
интерпретатора один или несколько специальных Муфлон-классов с определённым набором
методов. Экземпляры таких классов могут далее создаваться изнутри Муфлон-программ,
после чего вызовы их методов переадресуются процедурам внутри разделяемой библиотеки,
обеспечивая, тем самым, выполнение произвольных требуемых операций.

  Втыкало представляет собой системную разделяемую библиотеку (.dll для Windows
или .so для линуксообразных ОС). Она должна иметь одну стандартную экспортируемую
функцию с фиксированным именем (LoadPluginList), а также по одной специальной
экспортируемой функции для каждого класса. Сигнатуры всех этих функций (количество и
типы принимаемых параметров и тип возвращаемого результата) также должны соответствовать
определённому образцу. Здесь же отметим, что для того, чтобы имена требуемых функций
имели простой и предсказуемый вид, лишённый элементов C++-отделки, все экспортируемые
библиотекой функции должны иметь C-связывание.

  Так как библиотека обменивается с ядром интерпретатора объектами весьма сложных
классов, содержащих, в том числе, и поля STL-типов, то ядро (исполняемый файл, содержащий
исходный текст интерпретатора, например, MythlonInterpreter.exe) экспортирует эти классы,
а модуль втыкалы должен их импортировать, для чего перед подключением заголовков из
комплекта Муфлона (declares.h, runtime.h, statement.h, parse.h, throw_messages.h)
следует определить макрос MYTHLON_INTERPRETER_MODULE.

Кроме того, компиляцию втыкалы нужно производить совместно с файлом, позволяющими
компоновщику построить правильную таблицу импорта всех этих классов и функций. Таким
файлом при сборке проекта в ОС Windows служит так называемая "библиотека импорта",
которая образуется при компиляции самого ядра интерпретатора вместе с его исполняемым
модулем.

В случае применения инструментария MSVC эта библиотека будет представлять собой файл
MythlonInterpreter.lib. Его следует добавить в дополнительные зависимости проекта втыкалы
для ИСР Visual Studio.

При использовании инструментария MinGW библиотека импорта будет называться
libMythlonInterpreter.lib.a. Её следует подключить как библиотеку одним из параметров
командной строки компилятора (-lMythlonInterpreter.lib)

  Наконец, при работе в среде ОС типа Линукс никаких дополнительных "библиотек импорта"
и других явных связей библиотеки втыкалы с исполняемым модулем ядра интерпретатора не
требуется.

  В целом, механизм втыкал имеет весьма специфические уязвимости. Это связано с тем, что
между библиотекой втыкалы и ядром интерпретатора передаются весьма сложные типы данных,
т. е. классы, содержащие как поля, так и методы. Кроме того, эти классы лишь частично
определены в самом коде ядра и библиотек, а частично заимствуются из кода стандартной
библиотеки языка C++ - STL. Соответственно, возникающие здесь трудности ноят двоякий
характер.

  Во-первых, они связаны с тем, что способы передачи таких объектов в разделяемые
библиотеки до сих пор не стандартизированы и являются, в сущности, расширением стандарта,
обеспечиваемым каждым отдельным инструментарием по собственному усмотрению. Поэтому двоичной
совместимости между модулями, созданными разными компиляторами, как правило, не наблюдается.

  Кроме того, полностью провести экспорт всех необходимых функций-членов нужных классов
в динамическую  библиотеку также невозможно. Мы может экспортировать со стороны ядра (и,
соответсвенно, импортировать со стороны разделяемой библиотеки) только наши собственные
функции, разработанные собственно нами и сформулированные непосредственно в наших исходных
текстах. Но, так как интересующие нас в данном случае классы содержат также поля STL-типов,
то и часть требуемых функций-членов тоже находится именно там. И для выполнения экспорта таких
методов требуется уже вносить изменения в исходный код STL, что, разумеется, недопустимо.

  Поэтому работоспособность всей конструкции зиждется лишь на том, что находящийся в ядре
и динамическом модуле частично дублированный код STL обрабатывает свои данные согласованно,
т. е. представляет собой, в сущности, одно и то же. Наилучший способ обеспечить такое положение
вещей единственный - это происходит, если код STL в исполняемом модуле и разделяемой библиотеке
полностью совпадает, что возможно лишь в случае, если для сборки ядра и втыкалы использована
одна и та же версия STL одного и того же инструментария, т. е. они должны быть оттранслированы
одним и тем же компилятором одной и той же версии.

  Поэтому как ядро, так и модуль втыкалы обязательно должны быть скомпилированы одним и тем
же компилятором с одной и той же версией STL, следовательно, их крайне желательно всегда
перекомпилировать вместе, в рамках одного решения или даже одного проекта.

  Но даже тут возможны трудности. Они связаны с тем, что некоторые реализации STL (к счастью,
редко встречающиеся) в таких условиях всё равно нормально не работают, даже при полном совпадении
версий сборочного инструментария и рабочей библиотеки. Но, всё же, наиболее распространённые
реализации STL (в частности, STL из комплекта MSVC, MinGW, линуксовых GСС и CLang) работают
нормально и таких проблем не доставляют.

  С общей рекомендованной архитектурой дополнения можно познакомиться на примере файлов
проекта тестовой втыкалы MythonTestPlugin - testplug.h и testplug.cpp.

### Использование втыкал в программах на языке МУФЛОН.

  Втыкалы - способ подключения двоичных библиотек, которые будут экспортировать
набор функций для вызова их из Муфлон-программ, способных быстро выполнять такие операции,
производить которые средствами самого Муфлона либо времязатратно, либо вовсе невозможно
(например, запросы к операционной системе). Метод использования втыкал из Муфлон-программ
иллюстрирует данный пример:
  
        import "MythonTestPlugin", "plug"
        tst = plug_test()
        s = tst.print_hello()
        print tst.add_all(5, 6, 7.7, 8.8), s
        zp = tst.find_zero(5, 6, 9, 5, 0, 9, 10)
        zc = tst.find_char("ABCDabcd", "d")
        print zp, zc  

  Для подключения втыкалы к исполнительной среде используется директива import. Хотя
она и выглядит как команда языка, на самом деле она является директивой и обрабатывается
не в процессе работы программы, а ранее - при её синтаксическом разборе. Поэтому её параметры
(их может быть один либо два) могут быть только константными строками, а местоположение
её внутри различных структур программы не имеет значения - объекты втыкалы будут доступны
всюду для кода, расположенного после (ниже по тексту) директивы import.

  Первый параметр директивы - имя подключаемой втыкалы. По умолчанию оно совпадает с именем
файла соответствующей динамической библиотеки (с расширением или без него). Но есть возможность
произвольного преобразования этого имени и даже загрузки втыкал "из памяти" - в том случае,
если объемлющая среда, в которой работает интерпретатор, предоставляет классы и функции,
совместимые с теми, которые требуются для обеспечения работы механизма двоичных дополнений
Муфлона. Эти расширенные возможности подключения втыкал описаны ниже.

  Второй параметр - ведущий компонент псевдонима внутренних классов втыкалы. В приведённом
выше примере единственный внутренний класс тестовой втыкалы MythonTestPlugin имеет имя test.
В сочетании с вторым параметром директивы import ("plug") он будет доступен далее как plug_test.
Если бы втыкало содержало бы ещё один внешний класс (например, "gone"), то он был бы доступен
как plug_gone. Первый по порядку внешний класс втыкалы также будет доступен и без указания
его внутреннего имени - в данном случае как просто plug.

  Далее в обсуждаемом примере создаётся экземпляр класса test втыкалы MythonTestPlugin (tst),
а затем следует серия вызовов его методов, и командой print выводятся результаты их работы.

  Если простейший случай соответствия имени втыкалы и файла его разделяемой библиотеки, из
которой она будет загружена, вас не устраивает, то можно сделать следующее: использовать
дополнительный параметр синтаксического разборщика - разборочный контекст.

        class MyParseContext : public ParseContext
        {
        public:
            LoadLibraryDefine GetLoadLibraryDesc(const std::string& library_name) const
            {
                LoadLibraryDefine result;
                ...............
                ...............
                
                return result;
            }; 
        }
        
        parse::Lexer lexer(input);
        MyParseContext parse_context;
        auto program = ParseProgram(lexer, parse_context);
        
        runtime::SimpleContext context(output);
        runtime::Closure closure;
        program->Execute(closure, context);  

  Внутренняя функция-член класса MyParseConext, получая на вход первый аргумент
директивы import, возвращает значение типа LoadLibraryDefine, которое определяет природу
и имя (или адрес фабричной функции при загрузке "из памяти") подключаемой втыкалы.

### Правка исходного кода.

  Наконец, последний способ установления связи Муфлон-программы с внешней средой
уже требует непосредственной доработки интерпертатора, связанной с вмешательством
в его исходный код. И преимущество свободной программы (а предлагаемый интерпретатор
Муфлона является абсолютно свободной программой), что вы можете делать это свободно,
по своему усмотрению. Но пожалуйста, не забывайте поделиться своими наработками с
обществом.

  Наиболее рациональный способ доработки интерпретатора - введение дополнительных
специализированных внутренних классов. Проще всего сделать это, подражая реализации
внутреннего класса коллекции математических функций - класса math. Его конструктор и
все методы имеют фиксированное количесто аргументов, поэтому он существенно проще
класса array. Он не связан с какими-либо вспомогательными классами (как это происходит,
например, у словаря map по отношению к его итератору), что также позволяет
освободиться от лишних сложностей. Познакомиться с деталями его реализации можно в
файлах math_object.h, math_object_statement.h и math_object.cpp.

  Введя подходящие дополнительные классы, с помощью их методов можно выполнить из
программы на Муфлоне все нужные Вам операции во внешней среде.

Возможные доработки, дополнения и планы на будущее.
---------------------------------------------------

  На данный момент  содержание    синтаксиса языка вполне отвечает его основному
назначению   -  составлению  скриптов,  простых   сценариев   и  применению  как
специализированного   прикладного   языка,  встроенного  в   какую-либо  внешнюю
программную среду. Интерпретатор не обеспечивает,конечно, высокой вычислительной
производительности, но с этим можно  вполне примириться,  если написанные на нём
процедуры  вызываются  редко,  что   обычно  и  имеет  место при упомянутых выше
способах применения.

  Доводить состав языка  до  уровня,  позволяющего  создавать на нём уже крупные
программы   и   программные  комплексы,  вряд  ли  целесообразно.  Таких  языков
существует  очень  много  (вероятно, следовало бы сказать, даже слишком много) и
самых различных семейств и  типов. А так  как  Муфлон не  отличается  какой-либо
концептуальной новизной ни в каком отношении,  то  не  следует  плодить сущности
без  всякой  к тому необходимости. В принципе, можно утверждать, что в настоящей
версии языка программирование на нем уже является вполне комфортным и его  можно
считать достаточно зрелым и отвечающим своему основному назначению.

Единственный существенный недостаток, который можно отметить на данный момент - 
упомянутая выше строгая однопоточность исполнения программы. Программа всегда
исполняется в одном единственном потоке - том, в котором запущена функция Execute
корневого узла синтаксического дерева. И она не возвращает управление, пока
программа полностью не завершится. Никаких механизмов параллельности или
асинхронности в своём настоящем состоянии интерпретатор не предусматривает.

Но, как известно, многопоточность - один из основных трендов современного
программирования, что обуславливается как требованиями современных алгоритмов
и большим объёмом данных, обрабатываемых современным ПО, как и широким
распространением многоядерных процессоров, количество ядер в которых стремительно
растёт, а производительность на ядро остаётся практически постоянной. Поэтому
даже для скриптового языка следовало бы предусмотреть какой-нибудь механизм
многопоточного, параллельного, исполнения и обработки асинхронных вызовов.
Именно в этом направлении и будут двигаться в ближайшее время запланированные
доработки как языка, так и данного интерпретатора.

Компиляция и сборка проекта.
----------------------------

  В целях облегчения сборки к проекту приложены  сборочный  cmake-скрипт  и  уже
готовый  проект ("решение")  для Visual Studio. Каких-либо внешних нестандартных
зависимостей проект не имеет.
