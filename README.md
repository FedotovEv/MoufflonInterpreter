
Интерпретатор языка программирования МУФЛОН.
============================================

  Перед   вами     интерпретатор     одного     очень    специфического    языка
программирования   -   Mython.   Транскрипция  этого  слова  в  русский  алфавит
должна   выглядеть  приблизительно  как  "Митон",  но  для  того,  чтобы  слегка
поднять  настроение  всякому, читающему  эти  строки,  по-русски  далее мы будем
называть этот язык программирования так - "Муфлон".

  Сама  реализация  этого   интерпретатора   велась  одновременно  с  чтением  и
проработкой   известной   "книги   дракона"   -   Ахо,   Ульман,  пр.  "Принципы
разработки   компиляторов".   Так   что,   в   основном,   данный  проект  носит
учебно-образовательный    характер.   Практическое   применение   такому   очень
ограниченному   языку   найти   будет  весьма  трудно.  Однако,  в  конце  этого
документа    несколько    способов    такового    будет    всё    же    указано.  

  Что  же такое  Муфлон?  Как следует  даже  из  названия,  это некоторый, очень
сильно    урезанный    вариант    широко   распространённого   интерпретируемого
скриптового   языка   Питон. Руководящий принцип проектирования - минимализм. Из
прототипа исключена  масса  конструкций,  которые можно рассматривать как
"синтаксический сахар", а также те, которые могли бы затруднить проектирование
"теоретически ясного", архитектурно-чистого транслятора на основе стандартного
абстрактного синтаксического дерева.

  Описанию  самого  этого языка, его лексики и синтаксиса, будет посвящена отдельная
идущая ниже глава.

Описание языка программирования Муфлон.
---------------------------------------

  Муфлон     -     объектно-ориентированный      язык     программирования     с
поддержкой классов и наследования. Все методы классов — виртуальные.

* Числа.  
  На данный момент в языке Муфлон используются только целые числа. С ними  можно
выполнять  обычные  арифметические  операции:  сложение,  вычитание,  умножение,
целочисленное деление, а также деление по модулю (взятие остатка от деления).

* Строки.  
  Строковая  константа  в   Муфлоне   —   это   последовательность  произвольных
символов,  размещающаяся  на  одной  строке  и  ограниченная  двойными кавычками
"  или  одинарными  '.  Поддерживается  экранирование  спецсимволов  '\n', '\t',
'\'' и '\"'.

  Примеры строк в Муфлоне:

		"hello"  
		'world'  
		'long string with a double quote " inside'  
		"another long string with a single quote ' inside"  
		"string with a double quote \" inside"  
		'string with a single quote \' inside'  

  '', "" — пустые строки.  
  Строки в языке Муфлон — неизменяемые.
  
* Логические константы и None.

  Кроме   строковых  и   целочисленных   значений   язык   Муфлон   поддерживает
логические             значения             True             и            False.
Есть  также  специальное  значение  None,  выполнющее  функцию  пустого значения
(пустого   указателя).   Обратите   внимание,  логические  константы  пишутся  с
большой буквы.

* Комментарии.

  Муфлон  поддерживает  однострочные  комментарии,  начинающиеся  с  символа  \#.
Весь     следующий    текст    до    конца    текущей    строки    игнорируется.
\# внутри строк считается обычным символом.

		# это комментарий  
		x = 5 #это тоже комментарий  
		# в следующей строке # - обычный символ  
		hashtag = "#природа" 

* Идентификаторы.

  Идентификаторы  в  Муфлоне   используются  для  обозначения  имён  переменных,
классов   и   методов.  Правила  именования  идентификаторов  такие  же,  как  в
большинстве   других   языков   программирования:  начинаются  со  строчной  или
заглавной   латинской   буквы   либо  с  символа  подчёркивания.  Потом  следует
произвольная   последовательность,   состоящая   из   цифр,   букв   и   символа
подчёркивания.  
  Примеры   правильных   идентификаторов:   x,   _42,   do_something,   int2str.
Примеры                       неправильных                      идентификаторов:
4four   —   начинается   с   цифры;   one;two  —  содержит  символ,  который  не
относится к цифрам, буквам или знакам подчёркивания.

* Классы.

  В Муфлоне можно  определить  свой  тип,  создав  класс.  Класс  имеет  поля  и
методы,    поля    не    надо    объявлять    заранее.    Объявление    поля   -
первое  его  применение.  Объявление   класса   начинается  с   ключевого  слова
class, за которым следует идентификатор имени и объявление методов класса.

  Пример класса «Прямоугольник»:

      class Rect:
        def __init__(w, h):
          self.w = w
          self.h = h

        def area():
           return self.w * self.h 

* Важные особенности классов в Муфлоне:

  Специальный    метод    __init__     играет    роль    конструктора    —    он
автоматически       вызывается       при       создании      нового      объекта
класса.       Метод       __init__       может       отсутствовать.      Неявный
параметр     всех     методов    —    специальный    параметр    self,    аналог
указателя    this    в    C++.    Параметр    self    ссылается    на    текущий
объект   класса.   Поля   не   объявляются   заранее,  а  добавляются  в  объект
класса   при   первом   присваивании.   Поэтому   обращения   к   полям   класса
всегда    надо    начинать   с   self.,   чтобы   отличать   их   от   локальных
переменных. Все поля объекта — публичные.

  Новый объект ранее  объявленного  класса  создаётся  указанием  имени  класса,
за которым в скобках идут параметры, передаваемые методу __init__.

    r = Rect(10, 5) 

  В этой программе  создаётся  новый  объект  класса  Rect.  При  вызове  метода
__init__  параметр  w  будет  иметь  значение  10,  а  параметр h — 5. Созданный
прямоугольник будет доступен в переменной r.

* Типизация.

  Муфлон — это  язык  с  динамической  типизацией.  В  нём тип каждой переменной
определяется   во  время  исполнения  программы  и  может  меняться  в  ходе  её
работы.   Поэтому  какие-либо  механизмы  явного  указания  типа  переменной  не
требуются.

  Пример:

		x = 4  # переменная x связывается с целочисленным значением 4  
		# следующей командой переменная x связывается со значением 'hello'  
		x = 'hello'  
		y = True  
		x = y 

* Массивы

  Кроме упомянутых выше скалярных переменных, в языке предусмотрена специальная
поддержка массивов - способа группового хранения однородных переменных под одним
именем, доступ к каждой из которых выполняется указанием набора её порядковых
номеров (или координат). Размерность и количество элементов многомерных массивов
могут быть указаны сразу при их создании (аргументами конструктора), и могут быть
переопределены позже, с помощью специального метода.
При переописании массива всё его содержимое теряется.Исключением из этого правила
являются одномерные массивы, размер которых можно изменить с сохранением их
содержания. Кроме того, для одномерных векторов определены несколько
дополнительных методов, позволяющих динамически выполнять над ними некоторые
специальные операции.  
  Синтаксис объявления массива использует специальное ключевое слово array и
выглядит так:

        arr_1d = array(5) # arr_1d - одномерный массив с пятью элементами  
        arr_2d = array(6, 7) # arr_2d - двумерный массив с шестью строками и
        # семью столбцами
        arr_3d = array(3, 4, 5) # трехмерный массив, содержащий три плоскости,
        # в каждой из которых содержатся четыре строки с пятью элементами в каждой.

  То есть array можно рассматривать как имя особого предопределённого класса,
аргументы же его конструктора задают размерность массива (определяется количеством
аргументов) и количество его элементов (задаётся значениями этих аргументов).  
  Такая форма описания неслучайна. В Муфлоне массив внутренне действительно
организован как специальный встроенный класс с фиксированным набором собственных
методов, состав которых постоянен и не подлежит изменению программистом. Эти
методы обеспечивают основные сценарии доступа к элементам массива.  
Вот полный список методов, предоставляемых классом массива:

    + get(... indexes ...) - служит для считывания и установки значения элемента
    массива, определенного набором координат-индексов. Все индексы базируются к
    нулю (минимальный индекс элемента для каждой размерности равен 0).
    + get_array_dimensions() - получение количества измерений массива.
    + get_dimension_count(index_number) - получение количества элементов
    для размерности, определяемой аргументом index_number. Номер размерности
    базируется к 1 (младший индекс и соответствующая размерность имеют номер 1).
    + resize(... counters ...) - пересоздание массива с иной размерностью и
    количеством элементов.

  Следующие методы определены только для одномерных массивов. Применение их для
многомерных массивов приводит к возникновению ошибки периода исполнения.

    + push_back(new_element) - добавляет элемент new_element в конец массива.
    + back() - позволяет считать или установить последний элемент массива.
    + pop_back() - удаляет из массива последний элемент.

  Примеры применения вышеперечисленных методов:
  
        # сначала поработаем с одномерным массивом
        arr_1d = array(5)
        arr_1d.get(2) = 1
        arr_1d.get(3) = "str"
        arr_1d.push_back(6)
        arr_1d.push_back("rts")
        print "arr_1d:", arr_1d.get_array_dimensions(), arr_1d.get_dimension_count(1)
        # команда выше выводит такую строку: arr_1d 1 5
        print arr_1d.get(3), arr_1d.get(5), arr_1d.back()
        # эта команда выведет следующее : str 6 rts
        print arr_1d.get(2), arr_1d.get(2) \* 2, arr_1d.get(2) \* 3
        # ну а тут будет получено такое : 1 2 3
        # далее некоторые эксперименты с многомерным (двумерным) массивом
        x = 3
        y = 2
        arr_2d = array(6, 7)
        arr_2d.get(x, y) = "STR"
        arr_2d.get(2, 1) = 21
        arr_2d.get(y, x) = "RTS"
        print "arr_2d:", arr_2d.get_array_dimensions()
        # команда выше выводит такую строку: arr_2d 2
        print arr_2d.get_dimension_count(1), arr_2d.get_dimension_count(2)
        # здесь будет следующее: 6 7
        print arr_2d.get(x, y), arr_2d.get(2, 3)
        # эта команда выведет следующее : STR RTS
        print arr_2d.get(2, 1), arr_2d.get(2, 1) \* 2, arr_1d.get(2, 1) \* 3
        # ну а тут будет получено такое : 21 42 63

  Так как Муфлон - язык с динамической типизацией, в одном массиве могут храниться
переменные любых типов, на это не накладывается никаких ограничений. Некоторую
озадаченность читателя может вызвать работа метода get при его использовании для изменения
значений элементов массива. На самом деле это есть случай "косвенного присваивания",
описанного в этом документе ниже.

* Ассоциативные массивы

  Кроме обычных порядковых массивов, доступ к элементам которых выполняется прямым вычислением
их положения в памяти по их числовым индексам за время O(1), Муфлон поддерживает также
ещё один вид массивов - ассоциативные (словари).
Здесь индексом элемента является его единственное строковое имя - ключ. В качестве индекса-ключа
может выступать Муфлон-выражение любого типа, так как оно будет преобразовано в текстовую строку
так, как это делают описанные ниже функция str и команда print. Доступ к ассоциативному массиву,
как и прежде, осуществляется с помощью постоянного набора методов.
  Объявление словаря выглядит так:
  
        map_var = map()
  
  То есть ассоциативный массив - встроенный класс по имени map. За его фасадом скрывается также
стандартный библиотечный класс библиотеки STL C++ с таким же именем. Набор предоставляемых методов
выглядит так:

    + insert(key, value) - вставка в массив элемента value с ключом key.
    + find(key) - чтение или изменение уже существующего элемента с ключом key. Вызов метода с
    ключом, отсутствующем в ассоциативном массиве, вызывает ошибку периода исполнения.
    + erase(key) - удаление элемента с ключом key.
    + contains(key) - проверка наличия элемента с ключом key.

            keyb = "ququ"
            map_var.insert(keyb, 32)
            if map_var.contains(keyb):
              print map_var.find(keyb)
              map_var.erase(keyb)
            if not map_var.contains(keyb):
              print "OK"
            else
              print "Error"

  Также предусмотрено небольшое семейство методов, позволяющее обойти все существующие элементы
словаря с помощью механизма, несколько напоминающего C++ - итераторы.

    + begin() - возврат итератора, указывающего на первый элемент массива.
    + next(iterator) - передвигает итератор iterator вперед, перенацеливая его
    на следующий элемент словаря.
    + previous(iterator) - передвигает итератор iterator назад, перенацеливая его
    на предыдущий элемент словаря.
    + is_iterator_begin(iterator) - возвращает True, если итератор указывает на
    первый элемент словаря.
    + is_iterator_end(iterator) - возвращает True, если итератор указывает __за__
    последний элемент словаря. Разыменование такого итератора недопустимо.
    + key(iterator) - возвращает ключ элемента, соответствующего iterator.
    + value(iterator) - чтение или изменение элемента, на который указывает iterator.
    + release() - сообщает об окончании процесса перечисления элементов словаря. После вызова
    этого метода словаря все его итераторы считаются невалидными и их использование закончится
    исключением времени исполнения.

  Если iterator некорректен, возникает ошибка периода исполнения. Аналогично закончится
попытка разыменования (применения методов key() или value()) к итератору, указывающему __за__
последний элемент ассоциативного массива. Проверяйте данное обстоятельство с помощью метода
is_iterator_end().

            i = 0
            while i < 10:        
              map_var.insert(i, 2 * i)
              i = i + 1
              
            map_iter = map_var.begin()
            while not map_var.is_iterator_end(map_iter):
              print map_var.key(map_iter), map_var.value(map_iter)
              map_var.next(map_iter)
            map_var.release()

  На корректность операции обхода элементов накладывается следующее, весьма жесткое ограничение. В
ходе всего процесса состав ключей словаря не должен меняться. То есть с момента получения "итератора"
методом begin() и до завершения перечисления элементов вызовом release() накладывается строгий запрет
на обращение к методам insert(key) и erase(key) соответствующего ассоциативного массива. Попытка
сделать это приведёт к ошибке периода исполнения. Аналогичный результат получится при использовании
любого итератора после вызова метода release().

* Операции.

  В Муфлоне определены:
  +  Арифметические операции для целых чисел, деление выполняется нацело.
  Деление на ноль вызывает ошибку времени выполнения.
  + Операция конкатенации строк, например: s = 'hello, ' + 'world'.
  + Операции сравнения строк и целых чисел ==, !=, <=, >=, <, >; сравнение
  строк выполняется лексикографически.
  + Логические операции and, or, not.
  + Унарный минус.
  
  Приоритет операций (в порядке убывания приоритета):
  + Унарный минус.
  + Умножение, деление и остаток от деления.
  + Сложение и вычитание.
  + Операции сравнения.
  + Логические операции.

  Порядок вычисления выражений может быть изменён скобками:

      print 2 + 3 * 4   # выведет 14
      print (2 + 3) * 4 # выведет 20 

    В  Муфлоне  операция  сложения  кроме  чисел  и  строк  применима  к  объектам
  классов со специальным методом \_\_add__:

      class Fire:
        def __init__(obj):
          self.obj = obj
      
        def __str__():
          return "Burnt " + str(self.obj)
      
      class Tree:
        def __str__():
          return "tree"
      
      class Matches: # Спички
        # операция сложения спичек с другими объектами превращает их в огонь
        def __add__(smth):
          return Fire(smth)
      
      result = Matches() + Tree()
      print result             # Выведет Burnt tree
      print Matches() + result # Выведет Burnt Burnt tree 

    Операции  сравнения  применяются  не  только  к  числам  и  строкам,  но  и  к
  объектам   классов,   имеющих   методы   \_\_eq__   (проверка  «равно»)  и  \_\_lt__
  (проверка   «меньше»).   Используя   эти   методы,   релизуются   все   операции
  сравнения.

      class Person:
        def __init__(name, age):
          self.name = name
          self.age = age
        def __eq__(rhs):
          return self.name == rhs.name and self.age == rhs.age
        def __lt__(rhs):
          if self.name < rhs.name:
              return True
          return self.name == rhs.name and self.age < rhs.age
      
      print Person("Ivan", 10) <= Person("Sergey", 10) # True
      print Person("Ivan", 10) <= Person("Sergey", 9)  # False 

* Функция str.

  Функция str преобразует  переданный  ей  аргумент  в  строку.  Если аргумент —
объект  класса,  она  вызывает  у  него  специальный  метод \_\_str__ и возвращает
результат.  Если  метода  \_\_str__  в  классе  нет,  функция возвращает строковое
представление адреса объекта в памяти.

  Примеры:

      str('Hello') вернёт строку Hello;
      str(100500) вернёт строку 100500;
      str(False) вернёт строку False;
      str(Rect(3, 4)) вернёт адрес объекта в памяти, например 0x2056fd0.
      
      Пример класса с методом __str__:
      class Rect(Shape):
        def __init__(w, h):
          self.w = w
          self.h = h
      
        def __str__():
          return "Rect(" + str(self.w) + 'x' + str(self.h) + ')' 

  Выражение str(Rect(3, 4)) вернёт строку Rect(3x4).

* Команда print.

  Специальная   команда   print    принимает   набор   аргументов,   разделённых
запятой,  печатает  их  в  стандартный  вывод  и  дополнительно  выводит перевод
строки. Посмотрите на этот код:

      x = 4
      w = 'world'
      print x, x + 6, 'Hello, ' + w 

  Он выведет:  
  4 10 Hello, world 

  Команда  print вставляет  пробел  между  выводимыми  значениями.  Если  ей  не
передать  аргументы,  она  просто  выведет  перевод  строки. Чтобы преобразовать
каждый  свой  аргумент  в  строку,  команда  print  вызывает  для  него  функцию
str.  Таким  образом,  команда  print  Rect(20,  15)  выведет  в  stdout  строку
Rect(20x15).

* Условный оператор.

  В Муфлоне есть условный оператор. Его синтаксис:

      if <условие>:
        <действие 1>
        <действие 2>
        ...
        <действие N>
      else:
        <действие 1>
        <действие 2>
        ...
        <действие M> 

  <условие>   —   это   произвольное  выражение,  за  которым  следует  двоеточие.
Если  условие  истинно,  выполняются  действия  под  веткой  if,  если  ложно  —
действия   под   веткой   else.  Наличие  ветки  else  необязательно.  <условие>
может   содержать  сравнения,  а  также  логические  операции  and,  or  и  not.
Условие  будет  истинным  или  ложным  в  зависимости  от  того, какой тип имеет
вычисленное выражение.

  Если  результат  вычисления   условия   —   значение   логического  типа,  для
проверки истинности условия используется именно оно.

  Примеры:

      if x > 0:
      if s != 'Jack' and s != 'Ann':

  Если  результат  вычисления   условия   —   число,  условие  истинно  тогда  и
только тогда, когда это число не равно нулю.

  Если  результат  вычисления   условия   —  строка,  условие  истинно  тогда  и
только   тогда,   когда   эта  строка  имеет  ненулевую  длину.  Если  результат
вычисления   условия   —   объект   класса,   условие  истинно.  Если  результат
вычисления условия — None, условие ложно.

  Действия в ветках  if  и  else  набраны  с  отступом  в два пробела. Вообще, в
языке   Муфлон  команды  объединяются  в  блоки  отступами.  Один  отступ  равен
двум    пробелам.    Отступ    в    нечётное   количество   пробелов   считается
некорректным.

  Сравните:

      if x > 0:
        x = x + 1
      print x
      
      if x > 0:
        x = x + 1
        print x 

  Первая команда print  x  будет  выполняться  всегда,  вторая  —  только если x
больше 0. Вложенность условий может быть произвольной:

      if x > 0:
        if y > 0:
          print "Эта строка выведется, если x и y положительные"
      else:
        print "Эта строка выведется, если x <= 0" 

* Оператор цикла while.

  Муфлон включает в свой состав также обычный универсальный оператор цикла с
предусловием. Его синтаксис выглядит так:

        while <условие>:
          <действие 1>
          <действие 2>
          ...
          <действие N>

  Участок кода, входящий в блок цикла (набранный с отступом в два пробела), будет
выполняться многократно, пока <условие> буде истинным. Правила вычисления условия
аналогичны таковым в операторе if и описаны выше. Предусмотрены также две дополнительных
команды, позволяющих досрочно перейти к следующей итерации цикла, а также немедленно
прервать его исполнение. Для перехода к следующей итерации служит команда continue,
а для досрочного завершения цикла - команда break.
    
    + break    
      
      Команда break немедленно завершает цикл. Ниже приведен типичный способ её
    применения:
    
            while <условие 1>:
              <действие 1>
              if <условие 2>:
                break
              <действие 2>
            
            <действие 3>
        
        Если при выполнении оператора if <условие 2> это условие будет вычислено как
        истинное, то последующее выполнение команды break приведет к немедленному выходу
        из цикла и передаче управления на <действие 3>.
    
    + continue

            while <условие 1>:
              <действие 1>
              if <условие 2>:
                continue
              <действие 2>
            
            <действие 3>

        В случае, если при выполнении оператора if <условие 2> окажется истинным, то
        то при дальнейшем исполнении команды continue управление тут же будет передано
        в начало цикла к точке проверки истинности <условия 1>. И если оно также будет в
        этот момент истинным, то выполнение цикла продолжится как обычно, с <действия 1>.
        Если же <условие 1> вычислится как ложное, то работа цикла прекратится и
        управление будет передано за его пределы, к <действию 3>.

* Наследование.

  В  языке  Муфлон  у  класса  может  быть  один  родительский  класс.  Если  он
есть,  он  указывается  в  скобках  после  имени  класса и до символа двоеточия.
В примере ниже класс Rect наследуется от класса Shape:

      class Shape:
        def __str__():
          return "Shape"
      
        def area():
          return 'Not implemented'
      
      class Rect(Shape):
        def __init__(w, h):
          self.w = w
          self.h = h
      
        def __str__():
          return "Rect(" + str(self.w) + 'x' + str(self.h) + ')'
      
        def area():
          return self.w * self.h 

  Наследование в языке  Муфлон,  как  и  ожидается,  приводит  к  тому,  что все
методы   родительского  класса  становятся  доступны  классу-потомку.  При  этом
все   методы   публичные  и  виртуальные.  Например,  код  ниже  выведет  Hello,
John:

      class Greeting:
        def greet():
          return "Hello, " + self.name()
      
        def name():
          return 'Noname'
      
      class HelloJohn(Greeting):
        def name():
          return 'John'
      
      greet_john = HelloJohn()
      print greet_john.greet() 

* Методы.

  Как вы могли заметить, методы в Муфлоне имеют синтаксис:

      def <имя метода>(<список параметров>):
        <действие 1>
        <действие 2>
        ...
        <действие N> 

  Ключевое  слово def  располагается  с  отступом  в  два  пробела  относительно
класса.  Инструкции,  составляющие  тело  метода,  имеют  отступ  в  два пробела
относительно  ключевого  слова  def.  Как  и  в случае полей класса, обращения к
полям и методам текущего класса надо начинать с self.:

      class Factorial:
        def calc(n):
          if n == 0:
            return 1
          return n * self.calc(n - 1)
      
      fact = Factorial()
      print fact.calc(4) # Prints 24 

  Этот пример  представляет  собой, наверное,  самую  распространённую функцию,
применяемую  в  информатике для демонстрации   механизма   рекурсии - факториал
(наряду с расчётом чисел Фибоначчи). Команда return завершает выполнение метода
и возвращает из него результат вычисления своего аргумента.   Если   исполнение
метода  не  достигает  команды  return,  метод возвращает None.

* Семантика присваивания.

  Как сказано выше,  Муфлон  —  это  язык  с  динамической типизацией, и все его
переменные   являются   указателями   на   области   памяти,   где  хранятся  их
действительные  на  момент  исполнения  инструкции  значения.  Поэтому  операция
присваивания  имеет  семантику  не  копирования  значения  в  область  памяти, а
изменения    адреса,   на   который   указывает   переменная.   Как   следствие,
переменные  только  ссылаются  на  значения,  а  не  содержат  их  копии. Пустой
(нулевой)   указатель   —   значение   None.   Код   ниже  выведет  2,  так  как
переменные x и y ссылаются на один и тот же объект:

      class Counter:
        def __init__():
          self.value = 0
      
        def add():
          self.value = self.value + 1
      
      x = Counter()
      y = x
      x.add()
      y.add()
      print x.value 

* Косвенное присваивание

  Муфлон поддерживет также особенную форму присваивания, которую можно назвать "косвенным".
Такое присваивание случится, если левая часть оператора присваивания будет являться вызовом
какого-нибудь метода, который вернет результат, ссылающийся не на область памяти,
непосредственно хранящую значение, а на некоторое поле собственного объекта.
Этот результат можно рассматривать как указатель на это поле (а с учетом описанного выше
принципа хранения переменных в языке, даже как указатель на указатель).  
  Для данной конструкции при дальнейшем исполнении операции присваивания эта переменная будет
перенацелена на ту область памяти, на которую указывает вычисленная правая часть оператора
косвенного присваивания.  
  Для возврата из метода указателя на поле служит специальная команда return_ptr. Вот
комплексный пример применения описываемой схемы:

      class Rect(Shape):
        def __init__(w, h):
          self.w = w
          self.h = h

        def get_w():
          return self.w

        def get_h():
          return self.h
      
        def get_w_ptr():
          return_ptr self.w

        def get_h_ptr():
          return_ptr self.h

      x_rect = Rect(10, 20)
      print x_rect.w, x_rect.h # Эта команда выведет: 10 20
      x_rect.get_w_ptr() = 100
      x_rect.get_h_ptr() = 200
      print x_rect.w, x_rect.h # Эта команда выведет: 100 200

  Фактически, это есть некоторая очень ограниченная поддержка указателей, обеспечивающая
простейшие способы их применения, но позволяющая при этом избежать большинства возникающих
с ними проблем безопасности. В частности, указатель можно вернуть только на поле объекта,
возврат указателя на локальные переменные метода или временные значения не допускается.
То есть такое применение return_ptr вызовет ошибку синтаксического разбора:

        def get_tmp_ptr():
          temp = 1
          return_ptr temp # Ошибка! Попытка возврата указателя на локальную переменную.

  Хранений полученного указателя тоже невозможно, его можно только немедленно использовать
в том же операторе. Если метод, возвращающий указатель, используется в правой части оператора
присваивания, то он автоматически "разыменовывается", то есть вместо указателя будет подставлено
значение соответствующей переменной. То есть конструкция

        a = x_rect.get_w_ptr()
        b = x_rect.get_h_ptr()

равносильна вот такой:

        a = x_rect.get_w()
        b = x_rect.get_h()

Все это в целом позволяет избежать основной уязвимости, связанной с указателями - проблемы
"висячего указателя" и несоответствия времени жизни указателя и его целевого объекта.

* Прочие ограничения.

  Результат  вызова  метода   или   конструктора   в   Муфлоне   —  терминальная
операция.  Её  результат  можно  присвоить  переменной  или  использовать в виде
параметра   функции   или   команды,   но   обратиться   к   полям   и   методам
возвращённого объекта напрямую нельзя:

      # Так нельзя
      print Rect(10, 5).w
      # А вот так можно
      r = Rect(10, 5)
      print r.w 

Способ запуска программ интерпретатором.
----------------------------------------

  Для исполнения программы  на  языке  Муфлон  описываемым  интерпретатором  она
должна быть подвергнута последовательно следующим стадиям преобразования:

1. Лексический разбор.
2. Синтаксический  анализ.  В  результате  его  будет  построено  синтаксическое
дерево программы.
3. Непосредственно исполнение дерева, построенного на предыдущем шаге.

Так всё это выглядит, собственно, в коде:

    parse::Lexer lexer(input);
    auto program = ParseProgram(lexer);

    runtime::SimpleContext context(output);
    runtime::Closure closure;
    program->Execute(closure, context);

  Входному   лексическому   анализатору    parse::Lexer   программа   передаётся
через     какой-либо     стандартный     поток,     приводимый     к    istream.
Результат   работы   лексического   разборщика  передаётся  для  синтаксического
анализа  через  параметр  функции  ParseProgram,  возвращающей  объект корневого
узла  абстрактного  синтаксического  дерева  программы.  Наконец,  вызывая метод
Execute  этого  узла  (он  есть  у  каждого узла построенного дерева), запускаем
программу  на  исполнение.  Аргументами  этого  метода  служат  таблица символов
программы  closure  и  вспомогательная  переменная  context,  хранящая состояние
исполнительской   среды.   Этот   контекст   служит   для   хранения   некоторых
параметров, используемых для исполнения отдельных операторов языка.

  Таким  оператором,  является,  в  частности,  команда  print.  Она  направляет
весь   свой   вывод   в   какой-либо   выходной  поток,  приводимый  к  ostream.
Конкретный поток, который будет использовать print, хранится в контексте.
  
  Создать  нужный  контекст   можно  с  помощью  класса  runtime::SimpleContext,
который   представляет   один   из   видов   такого   контекста,  совместимый  с
методами   Execute   синтаксического   дерева.  Его  конструктор  принимает  два
аргумента   -   выходной   поток   для   print  и  необязательный  указатель  на
функцию,  которая  будет  служить  каналом  обмена  информацией для специального
объекта __external (в приведённом примере он не показан).

Возможные области практического применения языка.
-------------------------------------------------

  Как    следует    из    вышеприведённого    описания,    возможности    языка
оставляют    весьма    двойственное   впечатление.   Безусловно,   его   нельзя
рассматривать  как  средство  разработки  крупных  программных  комплексов. Это
связано   как  с  ограничениями  самого  языка,  так  и  с  текущим  состоянием
исполнительской среды - предлагаемого интерпретатора.

  К  первым  относятся   прежде   всего  ограниченность  его  объектной  модели
и  механизмов,  которые,  вообще  говоря,  не обеспечивают выполнение принципов
ООП    в   части   инкапсуляции   классов   и   распределения   полномочий   на
использование   их   полей   и   методов.   Без  существенного  изменения  всех
внутренних   механизмов   трансляции   устранить   это  обстоятельство  нельзя,
поэтому с ним придётся примириться.

  Второй    крупный   и     фундаментальный     неустранимый    недостаток    -
принципиальная  однопоточность   хода   исполнения  программ.  При  принятых  в
интерпретаторе   архитектурных    решениях    обеспечить    наличие   в   языке
каких-либо    видов     многопоточности     и     асинхронности     тоже     не
представляется возможным.

  Все остальные недостатки   следует   отнести к преходящим и в ближайшее время
они,  так  или  иначе, будут исправлены. Среди таких можно указать следующие:

* отсутствие  поддержки  дробных  чисел  делает  невозможным  выполнение
  математических    вычислений   обычным   способом   (это   возможно   только   с
  применением   специальных   приёмов,  таких  как  введение  специального  класса
  для   чисел   с   плавающей  точкой).

* отсутствие каких-либо средств обеспечения модульности программ.

* со стороны интерпретатора не обеспечивается какая-либо поддержка обычных техник
  отладки программ или вспомогательного сервиса для внешнего отладчика.

  Всё это  очерчивает возможную  на  данный  область  применения  этого  языка -
встроенный  язык  простых  сценариев  для  какой-либо  иной программной системы.
Но  для  этого  нужно  предусмотреть  механизмы  взаимодействия интерпретатора с
объемлющим   комплексом,   в   который   он   будет   включён.   Описанию  таких
механизмов посвящён следующий небольшой раздел.

Взаимодействие интерпретатора языка Муфлон с внешней средой.
------------------------------------------------------------

  Взаимодействие     интерпретатора    с     внешней     программой     возможно
тремя основными способами. Два из них уже внутренне предусмотрены в интерпретаторе,
не требуют изменения его исходног кода и осуществляются путём предоставляемых им
интерфейсов. К ним относятся:

*  создание   нестандартного  потока  вывода.
*  применение специального системного объекта \_\_external.

  Для применения обоих этих способов задействуется специально сформированный
контекст исполнения программы, в котором хранятся все необходимые для этого
сведения.

  Нестандартный, пользовательский выходной поток должен быть приводим к ostream
и будет получать весь вывод команды print. Метод-получатель информации внутри 
такого потокового объекта, получая данные из программы на Муфлоне, может в
соответствии с ними предпринимать любые действия по своему усмотрению. Простой
пример такого взаимодействия приведён в приложенной к проекту демонстрационной
программе NonStdPrint.cpp.

  Второй     канал     обмена      информацией     с     Муфлон-программой -
использование    специального    объекта    __external. Любое обращение к его
полям или методам сопровождается вызовом указанной пользователем звонковой
функции ("функции обратного вызова"). Если при создании SimpleContext
использовать  двухоперандный вариант  конструктора,  то  второй операнд будет
указывать на функтор (любой   вызываемый   объект) типа LinkageFunction,
определённый так:

    namespace runtime
    {
        using LinkageReturn = variant<int, string>;
        using LinkageFunction = function<LinkageReturn(LinkCallReason,
                                const string&, const vector<string>&)>;
        .................................
    }

Эта функция принимает три аргумента:

1. Тип  операции  -  перечисление LinkCallReason - оно указывает  причину вызова
функции:  этот  параметр  принимает  значение CALL_REASON_WRITE_FIELD при записи
в  какое-либо  поле  объекта, CALL_REASON_READ_FIELD  при  чтении  из  него и 
CALL_REASON_CALL_METHOD при сигнализации о вызове какого-либо его метода.

2. Имя поля

3. Массив    (вектор)   строк,  образованный   из  значений,  которые  выступают
входными   аргументами  операции.  Каждая  строка  вектора  будет  формироваться
из   соответствующего   по  номеру  входного  значения  по  тому  же  алгоритму,
который  применяется  описанной  ранее  функцией  str.  При  выполнении операции
записи   в   поле   такой  аргумент  только  один  -  собственно,  то  значение,
которое  должно  быть  присвоено  полю.  Оно  будет  являться  нулевым элементом
вектора.  
  Операция  чтения  из  поля  вовсе не имеет входных аргументов, поэтому для неё
вектор будет пуст.  
  При вызове метода элементы массива заполняются строковыми представлениями всех
его фактических параметров. Они помещаются в массив в естественном порядке - в
том, в котором они располагаются в списке входных аргументов метода.

  В  процессе  исполнения  программы   при любом  обращении  к  полям  и методам
объекта __external (чтение или присваивание любых его полей, а также вызов любых
его методов)  будет  вызываться указанный   через   конструктор   контекста
SimpleContext  функтор,  аргументы которого заполняются описанным выше способом.

  При  осуществлении   операции  чтения   из   поля   объекта   функция   должна
вернуть   некоторое   значение.   Это   значение   принадлежит   к   вариантному
библиотечному  типу  STL  (std::variant)  и  может  содержать либо целочисленную
величину,   либо   строку.   Возвращенный   таким   способом   результат   будет
считаться    в    программе   текущим   значением   самого   этого   поля.   При
выполнении  записи  возвращаемое значение игнорируется.

  При вызове функции, произведенном в связи с обращением к какому-либо методу
объекта __external, возвращаемое значение функции трактуется аналогично случаю
чтения поля - рассматривается как значение, возвращенное этим методом.

  Пример   использования    этого   механизма    приведён   в   демонстрационной
программе ExternalObjectDemo.cpp.

  Наконец, третий способ установления связи Муфлон-программы с внешней средой
уже требует непосредственной доработки интерпертатора, связанной с вмешательством
в его исходный код. И преимущество свободной программы (а предлагаемый интерпретатор
Муфлона является абсолютно свободной программой), что вы можете делать это свободно,
по своему усмотрению. Но пожалуйста, не забывайте поделиться своими наработками с
обществом.

  Наиболее рациональный способ доработки интерпретатора - введение дополнительных
специализированных внутренних классов. Проще всего сделать это, подражая реализации
внутреннего класса ассоциативного массива - класса map. Его конструктор и все методы
имеют фиксированное количесто аргументов, поэтому он существенно проще класса array.
Познакомиться с деталями его реализации можно в файлах special_objects.h и
special_objects.cpp. Ещё более упростить реализацию можно, отказавшись от работы с
итератором, что, обыкновенно, в простых интерфейсных классах и не требуется.

  Введя подходящие дополнительные классы, с помощью их методов можно выполнить из
программы на Муфлоне все нужные Вам операции во внешней среде.

Возможные доработки, дополнения и планы на будущее.
---------------------------------------------------

  На данный момент содержание синтаксиса языка вполне отвечает его основному
назначению - составлению скриптов, простых сценариев и применению как специализированного
прикладного языка, встроенного в какую-либо внешнюю программную среду.
Интерпретатор не обеспечивает, конечно, высокой вычислительной производительности,
но с этим можно вполне примириться, если написанные на нём процедуры вызываются редко,
что обычно и имеет место при упомянутых выше способах применения.

  Доводить состав языка до уровня, позволяющего создавать на нём уже крупные программы
и программные комплексы, вряд ли целесообразно. Таких языков существует очень много
(вероятно, следовало бы сказать, даже слишком много) и самых различных семейств и типов.
А так как Муфлон не отличается какой-либо концептуальной новизной ни в каком отношении,
то не следует плодить сущности без всякой к тому необходимости.

  Едиственное на данный момент существенное ограничение - отсутствие встроенной поддержки
чисел с плавающей точкой. Оно непременно будет снято при дальнейшей доработке языка,
что позволит свободно применять интерпретатор в составе комплексов, требующих несложных
математических расчетов.

  Вполне возможно, что также будет добавлена простейшая поддержка модульности на уровне
исходного текста по типу директивы C-препроцессора #include. Также, вероятно, следует
обеспечить возможность подключения и двоичных библиотек, которые будут экспортировать
набор функций для вызова их из Муфлон-программ, способных быстро выполнять такие операции,
производить которые средствами самого Муфлона либо времязатратно, либо вовсе невозможно
(например, запросы к операционной системе). Необходимости каких-либо иных крупных
усовершенствований языка мы в данный момент не видим.

  В принципе, можно утверждать, что в настоящей версии языка программирование на нем
уже является вполне комфортным и его можно считать достаточно зрелым и отвечающим своему
основному назначению.

  Основной недостаток, который уже не связан непосредственно с языком, а относится к его
конкретному воплощению - данному транслятору - отсутствие отладчика. Причем структура
интерпретатора такова, что реализовать отладчик без внесения в него существенных изменений
на данный момент невозможно. Для применения стандартных техник отладки требуется жёсткая и
однозначная связь между потоком исполнения и исходным текстом программы, а так как
интерпретатор не является построчным исполнителем, а опирается на прдварительно
построенное синтаксическое дерево программы, то в процессе предварительных лексического
и синтаксического анализов такая связь утрачивается. Также пока нет простой возможности
для временной приостановки работы программы с возможностью дальнейшего её возобновления.

  Однако очевидно, что практическая разработка программ без отладчика очень проблематична,
поэтому для всех описанных выше проблем непременно будет предложено какое-нибудь
удовлетворительное решение.

Компиляция и сборка проекта.
----------------------------

  В   целях  облегчения  сборки  к  проекту  приложены  сборочный  cmake-скрипт  и
уже   готовый   проект   ("решение")   для  Visual  Studio.  Каких-либо  внешних
нестандартных зависимостей проект не имеет.
